

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>medaka.labels &mdash; Medaka 0.11.2 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> Medaka
          

          
          </a>

          
            
            
              <div class="version">
                0.11.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../benchmarks.html">Benchmarks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../snp.html">Variant calling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../methylation.html">Methylation calling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../walkthrough.html">Walkthrough</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../draft_origin.html">Origin of the draft sequence</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../development.html">Development</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../future.html">History and Future Directions</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Medaka</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
          <li><a href="../medaka.html">medaka</a> &raquo;</li>
        
      <li>medaka.labels</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for medaka.labels</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Schemes to encode and decode truth labels and network outputs.&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">abc</span>
<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">copy</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">from</span> <span class="nn">operator</span> <span class="kn">import</span> <span class="n">attrgetter</span>

<span class="kn">import</span> <span class="nn">intervaltree</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pysam</span>

<span class="kn">import</span> <span class="nn">medaka.common</span>
<span class="kn">import</span> <span class="nn">medaka.rle</span>
<span class="kn">import</span> <span class="nn">medaka.vcf</span>


<div class="viewcode-block" id="TruthAlignment"><a class="viewcode-back" href="../../medaka.html#medaka.labels.TruthAlignment">[docs]</a><span class="k">class</span> <span class="nc">TruthAlignment</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Process truth alignments.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alignment</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a `TruthAlignment` list from an `AlignedSegment`.</span>

<span class="sd">        :param alignment: `pysam.AlignedSegment`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">aln</span> <span class="o">=</span> <span class="n">alignment</span>  <span class="c1"># so we can get positions and labels later</span>
        <span class="c1"># initialise start and end (which might be moved)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">aln</span><span class="o">.</span><span class="n">reference_start</span>  <span class="c1"># zero-based</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">aln</span><span class="o">.</span><span class="n">reference_end</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_kept</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">medaka</span><span class="o">.</span><span class="n">common</span><span class="o">.</span><span class="n">get_named_logger</span><span class="p">(</span><span class="s1">&#39;TruthAlign&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_overlap_with</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">first</span><span class="p">,</span> <span class="n">second</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">((</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">),</span>
                               <span class="n">key</span><span class="o">=</span><span class="n">attrgetter</span><span class="p">(</span><span class="s1">&#39;aln.reference_start&#39;</span><span class="p">))</span>
        <span class="n">overlap</span> <span class="o">=</span> <span class="n">first</span><span class="o">.</span><span class="n">aln</span><span class="o">.</span><span class="n">reference_end</span> <span class="o">&gt;</span> <span class="n">second</span><span class="o">.</span><span class="n">aln</span><span class="o">.</span><span class="n">reference_start</span>
        <span class="k">if</span> <span class="n">overlap</span><span class="p">:</span>
            <span class="c1"># return positions of start and end of overlapping region</span>
            <span class="k">return</span> <span class="n">second</span><span class="o">.</span><span class="n">aln</span><span class="o">.</span><span class="n">reference_start</span><span class="p">,</span> <span class="n">first</span><span class="o">.</span><span class="n">aln</span><span class="o">.</span><span class="n">reference_end</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_filter_alignments</span><span class="p">(</span><span class="n">alignments</span><span class="p">,</span> <span class="n">region</span><span class="p">,</span> <span class="n">min_length</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
                           <span class="n">length_ratio</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">overlap_fraction</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Filter alignments to yield only segments suitable for training.</span>

<span class="sd">        :param alignments: iterable of `TruthAlignment` objects.</span>
<span class="sd">        :param region: `medaka.common.Region` obj. all alignments will be</span>
<span class="sd">            trimmed to this region.</span>
<span class="sd">        :param min_length: int, minimum length of alignment segment.</span>
<span class="sd">        :param length_ratio: float, in cases of overlap, ratio of</span>
<span class="sd">            longer segment / shorter segment</span>
<span class="sd">            above which the longer segment is assumed to be more reliable.</span>
<span class="sd">        :param overlap_fraction: float, length_ratio: float, in cases of</span>
<span class="sd">            overlap, fraction of shorter segment overlapping with the longer</span>
<span class="sd">            segment above which the segments are considered highly overlapping.</span>
<span class="sd">        :returns: list of `TruthAlignment` objects</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># don&#39;t want to modify original alignments</span>
        <span class="n">filtered_alignments</span> <span class="o">=</span> <span class="p">[</span><span class="n">copy</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">alignments</span><span class="p">]</span>

        <span class="c1"># git rid of any alignments with ambiguity bases in reference or query</span>
        <span class="k">def</span> <span class="nf">only_valid_symbols</span><span class="p">(</span><span class="n">al</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;`TruthAlignment` is free of ambiguous bases in ref and query.&quot;&quot;&quot;</span>
            <span class="n">symbols</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="s1">&#39;ACGT&#39;</span><span class="p">))</span>
            <span class="n">ref</span> <span class="o">=</span> <span class="n">al</span><span class="o">.</span><span class="n">aln</span><span class="o">.</span><span class="n">get_reference_sequence</span><span class="p">()</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
            <span class="n">query</span> <span class="o">=</span> <span class="n">al</span><span class="o">.</span><span class="n">aln</span><span class="o">.</span><span class="n">query_sequence</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
            <span class="n">result</span> <span class="o">=</span> <span class="nb">all</span><span class="p">([</span><span class="nb">set</span><span class="p">(</span><span class="n">ref</span><span class="p">)</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">symbols</span><span class="p">),</span>
                          <span class="nb">set</span><span class="p">(</span><span class="n">query</span><span class="p">)</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">symbols</span><span class="p">)])</span>
            <span class="k">return</span> <span class="n">result</span>

        <span class="n">filtered_alignments</span> <span class="o">=</span> <span class="p">[</span><span class="n">al</span> <span class="k">for</span> <span class="n">al</span> <span class="ow">in</span> <span class="n">filtered_alignments</span>
                               <span class="k">if</span> <span class="n">only_valid_symbols</span><span class="p">(</span><span class="n">al</span><span class="p">)]</span>

        <span class="k">for</span> <span class="n">al_i</span><span class="p">,</span> <span class="n">al_j</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">filtered_alignments</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
            <span class="n">first</span><span class="p">,</span> <span class="n">second</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">((</span><span class="n">al_i</span><span class="p">,</span> <span class="n">al_j</span><span class="p">),</span>
                                   <span class="n">key</span><span class="o">=</span><span class="n">attrgetter</span><span class="p">(</span><span class="s1">&#39;aln.reference_start&#39;</span><span class="p">))</span>
            <span class="n">overlap</span> <span class="o">=</span> <span class="n">first</span><span class="o">.</span><span class="n">_get_overlap_with</span><span class="p">(</span><span class="n">second</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">overlap</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">ovlp_start</span><span class="p">,</span> <span class="n">ovlp_end</span> <span class="o">=</span> <span class="n">overlap</span>
            <span class="n">shorter</span><span class="p">,</span> <span class="n">longer</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">((</span><span class="n">al_i</span><span class="p">,</span> <span class="n">al_j</span><span class="p">),</span>
                                     <span class="n">key</span><span class="o">=</span><span class="n">attrgetter</span><span class="p">(</span><span class="s1">&#39;aln.reference_length&#39;</span><span class="p">))</span>
            <span class="n">length_ratio_ij</span> <span class="o">=</span> <span class="p">(</span><span class="n">longer</span><span class="o">.</span><span class="n">aln</span><span class="o">.</span><span class="n">reference_length</span> <span class="o">/</span>
                               <span class="n">shorter</span><span class="o">.</span><span class="n">aln</span><span class="o">.</span><span class="n">reference_length</span><span class="p">)</span>
            <span class="n">overlap_fraction_ij</span> <span class="o">=</span> <span class="p">((</span><span class="n">ovlp_end</span> <span class="o">-</span> <span class="n">ovlp_start</span><span class="p">)</span> <span class="o">/</span>
                                   <span class="n">shorter</span><span class="o">.</span><span class="n">aln</span><span class="o">.</span><span class="n">reference_length</span><span class="p">)</span>
            <span class="c1"># 4 cases</span>
            <span class="c1"># we don&#39;t trust one more than the other</span>
            <span class="k">if</span> <span class="n">length_ratio_ij</span> <span class="o">&lt;</span> <span class="n">length_ratio</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">overlap_fraction_ij</span> <span class="o">&gt;=</span> <span class="n">overlap_fraction</span><span class="p">:</span>
                    <span class="c1"># 1) large overlap; significant ambiguity, discard both</span>
                    <span class="n">shorter</span><span class="o">.</span><span class="n">is_kept</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="n">longer</span><span class="o">.</span><span class="n">is_kept</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># 2) small overlap; trim overlapping portions of alignments</span>
                    <span class="n">first</span><span class="o">.</span><span class="n">end</span> <span class="o">=</span> <span class="n">ovlp_start</span>
                    <span class="n">second</span><span class="o">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">ovlp_end</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># we trust the longer one more than the shorter one</span>
                <span class="k">if</span> <span class="n">overlap_fraction_ij</span> <span class="o">&gt;=</span> <span class="n">overlap_fraction</span><span class="p">:</span>
                    <span class="c1"># 3) large overlap; discard shorter alignment</span>
                    <span class="n">shorter</span><span class="o">.</span><span class="n">is_kept</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># 4) small overlap; trim overlapping portion of</span>
                    <span class="c1"># shorter alignment</span>
                    <span class="n">second</span><span class="o">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">ovlp_end</span>

        <span class="c1"># trim starts and ends if needed</span>
        <span class="k">if</span> <span class="n">region</span><span class="o">.</span><span class="n">start</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">region</span><span class="o">.</span><span class="n">end</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">al</span> <span class="ow">in</span> <span class="n">filtered_alignments</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">region</span><span class="o">.</span><span class="n">start</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">al</span><span class="o">.</span><span class="n">start</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">region</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">al</span><span class="o">.</span><span class="n">start</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">region</span><span class="o">.</span><span class="n">end</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">al</span><span class="o">.</span><span class="n">end</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">region</span><span class="o">.</span><span class="n">end</span><span class="p">,</span> <span class="n">al</span><span class="o">.</span><span class="n">end</span><span class="p">)</span>
        <span class="c1"># do filtering</span>
        <span class="n">filtered_alignments</span> <span class="o">=</span> <span class="p">[</span><span class="n">al</span> <span class="k">for</span> <span class="n">al</span> <span class="ow">in</span> <span class="n">filtered_alignments</span>
                               <span class="k">if</span> <span class="p">(</span><span class="n">al</span><span class="o">.</span><span class="n">is_kept</span> <span class="ow">and</span>
                                   <span class="n">al</span><span class="o">.</span><span class="n">end</span> <span class="o">-</span> <span class="n">al</span><span class="o">.</span><span class="n">start</span> <span class="o">&gt;=</span> <span class="n">min_length</span><span class="p">)]</span>
        <span class="n">filtered_alignments</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">attrgetter</span><span class="p">(</span><span class="s1">&#39;start&#39;</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">filtered_alignments</span>

<div class="viewcode-block" id="TruthAlignment.bam_to_alignments"><a class="viewcode-back" href="../../medaka.html#medaka.labels.TruthAlignment.bam_to_alignments">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">bam_to_alignments</span><span class="p">(</span><span class="n">truth_bam</span><span class="p">,</span> <span class="n">region</span><span class="p">,</span> <span class="n">haplotag</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">min_length</span><span class="o">=</span><span class="mi">1000</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get processed truth alignments.</span>

<span class="sd">        :param truth_bam: (sorted indexed) bam with true sequence</span>
<span class="sd">            aligned to reference</span>
<span class="sd">        :param region: `medaka.common.Region` obj,</span>
<span class="sd">            (all alignments with any overlap with the interval</span>
<span class="sd">            start:end will be retrieved)</span>
<span class="sd">        :param haplotag: bam tag specifying which haplotype the alignment</span>
<span class="sd">            belongs to (for polyploid labels)</span>
<span class="sd">        :param min_length: minimum length for valid alignments.</span>

<span class="sd">        :returns: list of tuples where each tuple contains `TruthAlignment`</span>
<span class="sd">            for each haplotype trimmed to common genomic window.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">algns</span> <span class="o">=</span> <span class="n">TruthAlignment</span><span class="o">.</span><span class="n">_load_alignments</span><span class="p">(</span><span class="n">truth_bam</span><span class="p">,</span> <span class="n">region</span><span class="p">,</span> <span class="n">haplotag</span><span class="p">)</span>
        <span class="c1"># filter truth alignments to restrict ourselves to regions of the</span>
        <span class="c1"># ref where the truth is unambiguous in each haplotype</span>
        <span class="n">algns</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">h</span><span class="p">:</span> <span class="n">TruthAlignment</span><span class="o">.</span><span class="n">_filter_alignments</span><span class="p">(</span>
                <span class="n">h_algns</span><span class="p">,</span> <span class="n">region</span><span class="o">=</span><span class="n">region</span><span class="p">,</span> <span class="n">min_length</span><span class="o">=</span><span class="n">min_length</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">h</span><span class="p">,</span> <span class="n">h_algns</span> <span class="ow">in</span> <span class="n">algns</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="c1"># Group truth alignments from the haplotypes by genomic window and trim</span>
        <span class="c1"># to common genomic range</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">algns</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">grouped</span> <span class="o">=</span> <span class="n">TruthAlignment</span><span class="o">.</span><span class="n">_group_and_trim_by_haplotype</span><span class="p">(</span><span class="n">algns</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">grouped</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_group_and_trim_by_haplotype</span><span class="p">(</span><span class="n">alignments</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Group alignments by haplotype tag and trim to common genomic window.</span>

<span class="sd">        :param alignments: {haplotype: [`TruthAlignment`]}</span>
<span class="sd">        :returns: list of tuples where each tuple contains `TruthAlignment`</span>
<span class="sd">            for each haplotype trimmed to common genomic window.</span>

<span class="sd">        .. note:: We should avoid the situation of staggered alignments</span>
<span class="sd">             which could occur by independently chunking each haplotype</span>
<span class="sd">             by chunking the draft and aligning to both haplotypes, then</span>
<span class="sd">             chunking both haplotypes according to draft-chunks, then realining</span>
<span class="sd">             haplotype chunks to back to the draft - this should minimize</span>
<span class="sd">             staggering of truth alignments and hence the number of labels</span>
<span class="sd">             discarded.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span> <span class="o">=</span> <span class="n">medaka</span><span class="o">.</span><span class="n">common</span><span class="o">.</span><span class="n">get_named_logger</span><span class="p">(</span><span class="s2">&quot;Group_and_trim&quot;</span><span class="p">)</span>
        <span class="n">haplotypes</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">alignments</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">haplotypes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># haploid</span>
            <span class="n">grouped</span> <span class="o">=</span> <span class="p">[(</span><span class="n">a</span><span class="p">,)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">alignments</span><span class="p">[</span><span class="n">haplotypes</span><span class="p">[</span><span class="mi">0</span><span class="p">]]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># create interval trees for other haplotypes</span>
            <span class="n">trees</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">haplotypes</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="n">trees</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">=</span> <span class="n">intervaltree</span><span class="o">.</span><span class="n">IntervalTree</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">intervaltree</span><span class="o">.</span><span class="n">Interval</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">end</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">alignments</span><span class="p">[</span><span class="n">h</span><span class="p">]])</span>
            <span class="c1"># loop over alignments in first haplotype and find overlapping</span>
            <span class="c1"># alignments in other haplotypes. If there are multiple overlapping</span>
            <span class="c1"># alignments, take the one with the longest overlap.</span>
            <span class="n">grouped</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">alignments</span><span class="p">[</span><span class="n">haplotypes</span><span class="p">[</span><span class="mi">0</span><span class="p">]]:</span>
                <span class="n">group</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
                <span class="n">common_start</span><span class="p">,</span> <span class="n">common_end</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">end</span>
                <span class="k">for</span> <span class="n">h</span><span class="p">,</span> <span class="n">tree</span> <span class="ow">in</span> <span class="n">trees</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">h_algns</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">overlap</span><span class="p">(</span><span class="n">common_start</span><span class="p">,</span> <span class="n">common_end</span><span class="p">))</span>
                    <span class="c1"># no alignments on this haplotype, skip this alignment</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">h_algns</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">break</span>
                    <span class="c1"># find most overlapping alignment</span>
                    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">h_algns</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">ovlps</span> <span class="o">=</span> <span class="p">[</span><span class="nb">min</span><span class="p">(</span><span class="n">common_end</span><span class="p">,</span> <span class="n">o</span><span class="o">.</span><span class="n">end</span><span class="p">)</span>
                                 <span class="o">-</span> <span class="nb">max</span><span class="p">(</span><span class="n">common_start</span><span class="p">,</span> <span class="n">o</span><span class="o">.</span><span class="n">begin</span><span class="p">)</span>
                                 <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">h_algns</span><span class="p">]</span>
                        <span class="n">h_algn</span> <span class="o">=</span> <span class="n">h_algns</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">ovlps</span><span class="p">)]</span><span class="o">.</span><span class="n">data</span>
                    <span class="c1"># keep this alignment</span>
                    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">h_algns</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">h_algn</span> <span class="o">=</span> <span class="n">h_algns</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>

                    <span class="n">common_start</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">common_start</span><span class="p">,</span> <span class="n">h_algn</span><span class="o">.</span><span class="n">start</span><span class="p">)</span>
                    <span class="n">common_end</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">common_end</span><span class="p">,</span> <span class="n">h_algn</span><span class="o">.</span><span class="n">end</span><span class="p">)</span>
                    <span class="n">group</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">h_algn</span><span class="p">)</span>
                <span class="c1"># skip this group</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">haplotypes</span><span class="p">):</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Skipping </span><span class="si">{}</span><span class="s1">:</span><span class="si">{}</span><span class="s1">-</span><span class="si">{}</span><span class="s1">; missing alignment for haplotype&#39;</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">aln</span><span class="o">.</span><span class="n">reference_name</span><span class="p">,</span>
                                           <span class="n">a</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">end</span><span class="p">))</span>
                    <span class="k">continue</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># trim all alignments to common start/end</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">group</span><span class="p">:</span>
                        <span class="n">i</span><span class="o">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">common_start</span>
                        <span class="n">i</span><span class="o">.</span><span class="n">end</span> <span class="o">=</span> <span class="n">common_end</span>
                    <span class="n">grouped</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">group</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">grouped</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_load_alignments</span><span class="p">(</span><span class="n">truth_bam</span><span class="p">,</span> <span class="n">region</span><span class="p">,</span> <span class="n">haplotag</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create list of `TruthAlignment` s from a truth bam.</span>

<span class="sd">        :param truth_bam: (sorted indexed) bam with true sequence(s) aligned</span>
<span class="sd">            to reference</span>
<span class="sd">        :param region: `medaka.common.Region`</span>
<span class="sd">        :param haplotag: bam tag specifying which haplotype the alignment</span>
<span class="sd">            belongs to (for polyploid labels)</span>

<span class="sd">        :returns: {haplotype: [`TruthAlignment`]}</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">alignments</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">pysam</span><span class="o">.</span><span class="n">AlignmentFile</span><span class="p">(</span><span class="n">truth_bam</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">bamfile</span><span class="p">:</span>
            <span class="n">aln_reads</span> <span class="o">=</span> <span class="n">bamfile</span><span class="o">.</span><span class="n">fetch</span><span class="p">(</span>
                <span class="n">reference</span><span class="o">=</span><span class="n">region</span><span class="o">.</span><span class="n">ref_name</span><span class="p">,</span>
                <span class="n">start</span><span class="o">=</span><span class="n">region</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">region</span><span class="o">.</span><span class="n">end</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">aln_reads</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">is_unmapped</span> <span class="ow">or</span> <span class="n">r</span><span class="o">.</span><span class="n">is_secondary</span><span class="p">):</span>
                    <span class="k">continue</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">hap</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">get_tag</span><span class="p">(</span><span class="n">haplotag</span><span class="p">)</span> <span class="k">if</span> <span class="n">haplotag</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
                    <span class="n">alignments</span><span class="p">[</span><span class="n">hap</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">TruthAlignment</span><span class="p">(</span><span class="n">r</span><span class="p">))</span>

        <span class="n">logger</span> <span class="o">=</span> <span class="n">medaka</span><span class="o">.</span><span class="n">common</span><span class="o">.</span><span class="n">get_named_logger</span><span class="p">(</span><span class="s2">&quot;TruthAlign&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">hap</span> <span class="ow">in</span> <span class="n">alignments</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">alignments</span><span class="p">[</span><span class="n">hap</span><span class="p">]</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">attrgetter</span><span class="p">(</span><span class="s1">&#39;start&#39;</span><span class="p">))</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Retrieved </span><span class="si">{}</span><span class="s2"> alignments for haplotype </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">alignments</span><span class="p">[</span><span class="n">hap</span><span class="p">]),</span> <span class="n">hap</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">alignments</span></div>


<span class="n">label_schemes</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>


<div class="viewcode-block" id="LabelSchemeRegistrar"><a class="viewcode-back" href="../../medaka.html#medaka.labels.LabelSchemeRegistrar">[docs]</a><span class="k">class</span> <span class="nc">LabelSchemeRegistrar</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Class for registering label schemes.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">clsname</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">attrs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Register class to `label_schemes` dict upon instantiation.&quot;&quot;&quot;</span>
        <span class="n">newclass</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">LabelSchemeRegistrar</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span>
            <span class="bp">cls</span><span class="p">,</span> <span class="n">clsname</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">attrs</span><span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">register_label_scheme</span><span class="p">(</span><span class="n">clsname</span><span class="p">,</span> <span class="n">newclass</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">newclass</span>

<div class="viewcode-block" id="LabelSchemeRegistrar.register_label_scheme"><a class="viewcode-back" href="../../medaka.html#medaka.labels.LabelSchemeRegistrar.register_label_scheme">[docs]</a>    <span class="k">def</span> <span class="nf">register_label_scheme</span><span class="p">(</span><span class="n">clsname</span><span class="p">,</span> <span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add `LabelScheme` to `label_schemes` dict.&quot;&quot;&quot;</span>
        <span class="c1"># do not display base class as command line option</span>
        <span class="k">if</span> <span class="n">clsname</span> <span class="o">!=</span> <span class="s1">&#39;BaseLabelScheme&#39;</span><span class="p">:</span>
            <span class="n">label_schemes</span><span class="p">[</span><span class="n">clsname</span><span class="p">]</span> <span class="o">=</span> <span class="bp">cls</span></div></div>


<div class="viewcode-block" id="LabelSchemeMeta"><a class="viewcode-back" href="../../medaka.html#medaka.labels.LabelSchemeMeta">[docs]</a><span class="k">class</span> <span class="nc">LabelSchemeMeta</span><span class="p">(</span><span class="n">abc</span><span class="o">.</span><span class="n">ABC</span><span class="p">,</span> <span class="n">LabelSchemeRegistrar</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Metaclass facilitating registration of `LabelScheme` s.&quot;&quot;&quot;</span>

    <span class="k">pass</span></div>


<div class="viewcode-block" id="BaseLabelScheme"><a class="viewcode-back" href="../../medaka.html#medaka.labels.BaseLabelScheme">[docs]</a><span class="k">class</span> <span class="nc">BaseLabelScheme</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">LabelSchemeMeta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base class for labelling schemes.</span>

<span class="sd">    Labels are &#39;truth&#39; or &#39;y&#39; vectors used to train models.</span>
<span class="sd">    Models aim to predict a label (y) from a feature (X).</span>

<span class="sd">    A LabelScheme contains all logic for creating label vectors</span>
<span class="sd">    from a source of truth (typically an alignment of true reference</span>
<span class="sd">    sequence(s) to a draft sequence).</span>

<span class="sd">    A LabelScheme class also contains all logic for converting the</span>
<span class="sd">    model output into useful output (usually  a consensus</span>
<span class="sd">    sequence or a set of variant calls).</span>

<span class="sd">    Encoding (conversion of truth alignments to training vectors):</span>

<span class="sd">    The public method `self.encode` converts alignments</span>
<span class="sd">    to arrays of integer-encoded intermediate representations that</span>
<span class="sd">    are saved to file during feature creation.</span>
<span class="sd">    These private method must be implemented.</span>

<span class="sd">        - `_alignment_to_pairs` (called by _alignment_to_labels)</span>
<span class="sd">        - `_labels_to_encoded_labels`</span>

<span class="sd">    At training time, it is necessary to call the following public</span>
<span class="sd">    method for the conversion of intermediate forms saved to file to</span>
<span class="sd">    training vectors input to the model training process.</span>

<span class="sd">        - `encoded_labels_to_training_vectors`</span>

<span class="sd">    Decoding (interpretation of network outputs):</span>

<span class="sd">    For SNP calling, the public method is `self.decode_snps`</span>
<span class="sd">    This private method must be implemented.</span>

<span class="sd">        - `_prob_to_snp` (for SNP decoding)</span>

<span class="sd">    Public methods may also be defined for other types of decoding.</span>

<span class="sd">    For example, the concrete HaploidLabelScheme defines:</span>

<span class="sd">        - `decode_consensus`</span>
<span class="sd">        - `decode_variants`</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># default set of symbols used throughout all LabelSchemes</span>
    <span class="n">symbols</span> <span class="o">=</span> <span class="s1">&#39;*ACGT&#39;</span>

    <span class="nd">@property</span>
    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">n_elements</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return number of elements provided by truth alignment.</span>

<span class="sd">        (Mostly) synonymous with ploidy. i.e. n_elements = 2 where</span>
<span class="sd">        two symbols are provided for the two haplotypes of a truth</span>
<span class="sd">        alignment for diploid training.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mi">1</span>

    <span class="nd">@property</span>
    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">num_classes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return number of elements in output layer of neural network.&quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">padding_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the integer encoding used to denote a gap.</span>

<span class="sd">        Used to inform calling programs that need to expand</span>
<span class="sd">        label arrays to align with feature arrays,</span>
<span class="sd">        where reads introduce minor positions.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_singleton</span><span class="p">(</span><span class="n">it</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Test whether iterable contains one unique element.</span>

<span class="sd">        :param it: iterable</span>

<span class="sd">        :returns: bool, iterable contains one unique element</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">it</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_phred</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">cap</span><span class="o">=</span><span class="mf">70.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate phred quality score.</span>

<span class="sd">        :param err: float, error probability</span>
<span class="sd">        :param cap: float, maximum q score (prevent inf)</span>

<span class="sd">        :returns: float, phred quality score</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># add smallest positive usable number to err to avoid</span>
        <span class="c1"># RuntimeWarning: divide by zero encountered in log10</span>
        <span class="n">err</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">tiny</span>
        <span class="n">q</span> <span class="o">=</span> <span class="o">-</span><span class="mi">10</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">cap</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_pfmt</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Cast float to string with 3 decimal places.</span>

<span class="sd">        Used to format probabilities and quality scores for vcf output.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{:.3f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">_alignment_to_pairs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">aln</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert `pysam.AlignedSegment` to aligned pairs.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_alignments_to_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">truth_alns</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert `TruthAlignment` s to nd.array of positions and labels.</span>

<span class="sd">        :param truth_alns: tuple of `TruthAlignment` s for each haplotype</span>
<span class="sd">            spanning the same genomic range</span>

<span class="sd">        :returns: tuple(positions, label_array)</span>
<span class="sd">            - positions: numpy structured array with &#39;major&#39;</span>
<span class="sd">            (reference position index) and &#39;minor&#39;</span>
<span class="sd">            (trailing insertion index) fields.</span>

<span class="sd">            - label_array: numpy array of self.n_elements tuples</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_haps</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">truth_alns</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n_haps</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_elements</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> alignments were passed to </span><span class="si">{}</span><span class="s1">, requires </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">n_haps</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_elements</span><span class="p">))</span>

        <span class="c1"># ensure all alignments have same start and end</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_singleton</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">start</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">truth_alns</span><span class="p">)</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_singleton</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">end</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">truth_alns</span><span class="p">)):</span>

            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Alignments must have identical </span><span class="se">\</span>
<span class="s1">                genomic start and end.&#39;</span><span class="p">)</span>

        <span class="c1"># list of dicts mapping position to symbol for haplotypes</span>
        <span class="n">pos_maps</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">aln</span> <span class="ow">in</span> <span class="n">truth_alns</span><span class="p">:</span>
            <span class="c1"># default to gap on lookup</span>
            <span class="n">pos_to_symbol</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="s1">&#39;*&#39;</span><span class="p">)</span>
            <span class="n">ins_count</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="n">labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_alignment_to_pairs</span><span class="p">(</span><span class="n">aln</span><span class="o">.</span><span class="n">aln</span><span class="p">)</span>
            <span class="n">trimmed_labels</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">dropwhile</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">aln</span><span class="o">.</span><span class="n">start</span><span class="p">),</span> <span class="n">labels</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">rpos</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">trimmed_labels</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">rpos</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">rpos</span> <span class="o">&gt;=</span> <span class="n">aln</span><span class="o">.</span><span class="n">end</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="k">if</span> <span class="n">rpos</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">ins_count</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ins_count</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">current_pos</span> <span class="o">=</span> <span class="n">rpos</span>

                <span class="n">pos</span> <span class="o">=</span> <span class="p">(</span><span class="n">current_pos</span><span class="p">,</span> <span class="n">ins_count</span><span class="p">)</span>
                <span class="n">pos_to_symbol</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">label</span>

            <span class="n">pos_maps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pos_to_symbol</span><span class="p">)</span>

        <span class="c1"># get ordered positions present in any haplotype mapping</span>
        <span class="n">positions</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span>
            <span class="n">h</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">pos_maps</span><span class="p">)))</span>

        <span class="c1"># n_element tuples of symbols from haplotypes</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">pos_maps</span><span class="p">)</span>
                  <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="n">positions</span><span class="p">]</span>
        <span class="n">positions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">positions</span><span class="p">,</span>
                             <span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;major&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;minor&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)])</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">positions</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span>

    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">_labels_to_encoded_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert list of label tuples to array of integer encoded labels.</span>

<span class="sd">        The logic of many to one mappings, where multiple labels</span>
<span class="sd">        map to a common integer encoding is specified here.</span>

<span class="sd">        :param labels: list of label tuples</span>

<span class="sd">        :returns: np.ndarray of integer (tuples)</span>
<span class="sd">        &quot;&quot;&quot;</span>

<div class="viewcode-block" id="BaseLabelScheme.encoded_labels_to_training_vectors"><a class="viewcode-back" href="../../medaka.html#medaka.labels.BaseLabelScheme.encoded_labels_to_training_vectors">[docs]</a>    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">encoded_labels_to_training_vectors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">enc_labels</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert integer (tuple) encoded labels to truth vectors.</span>

<span class="sd">        (e.g. one-hot encoded truth vectors) that represent the truth</span>
<span class="sd">        for comparison with network output logits in</span>
<span class="sd">        e.g. metric(truth, pred) or loss(truth, pred)) functions.</span>

<span class="sd">        :param enc_labels: np.ndarray of integer (tuples)</span>

<span class="sd">        :returns: np.ndarray of training vectors</span>
<span class="sd">        &quot;&quot;&quot;</span></div>

    <span class="nd">@property</span>
    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">_encoding</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a dictionary mapping from label tuple to integer (tuple).</span>

<span class="sd">        This property is accessed by methods that are responsible</span>
<span class="sd">        for encoding. Also, it can be written to file in order to</span>
<span class="sd">        log the encoding scheme used.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="nd">@functools</span><span class="o">.</span><span class="n">lru_cache</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_decoding</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a dictionary mapping from integer (tuple) to label tuple.</span>

<span class="sd">        Inverse of encoding.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_encoding</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_unitary_encoding</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a dictionary mapping from all symbol 1-tuples to integers.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_unitary_labels</span><span class="p">())}</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_unitary_decoding</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a dictionary mapping from integers to all symbol 1-tuples.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unitary_encoding</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

<div class="viewcode-block" id="BaseLabelScheme.encode"><a class="viewcode-back" href="../../medaka.html#medaka.labels.BaseLabelScheme.encode">[docs]</a>    <span class="k">def</span> <span class="nf">encode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">truth_alns</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert truth alignment(s) to array of intermediate representation.</span>

<span class="sd">        In most cases the intermediate representation consists of integers.</span>

<span class="sd">        :param truth_alns: tuple of `pysam.AlignedSegment` s for each haplotype</span>
<span class="sd">            spanning the same genomic range.</span>

<span class="sd">        :returns: tuple(positions, training_vectors)</span>

<span class="sd">            - positions: numpy structured array with &#39;major&#39;</span>
<span class="sd">              (reference position index) and &#39;minor&#39;</span>
<span class="sd">              (trailing insertion index) fields.</span>

<span class="sd">            - encoded: nd.array of encoded labels</span>

<span class="sd">        .. note ::</span>
<span class="sd">            It is generally the case that the returned encoded labels must be</span>
<span class="sd">            padded with encoded gap labels when aligned to corresponding</span>
<span class="sd">            training feature data.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Labels is a list of tuples with alleles (&#39;A&#39;, ), (&#39;A&#39;, &#39;C&#39;), (&#39;C&#39;, 3)</span>
        <span class="n">positions</span><span class="p">,</span> <span class="n">labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_alignments_to_labels</span><span class="p">(</span><span class="n">truth_alns</span><span class="p">)</span>

        <span class="c1"># Encoded is an array of integers</span>
        <span class="n">encoded</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_labels_to_encoded_labels</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">positions</span><span class="p">,</span> <span class="n">encoded</span></div>

    <span class="k">def</span> <span class="nf">_unitary_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return all symbol 1-tuples.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">((</span><span class="n">s</span><span class="p">,)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">symbols</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_unordered_label_combinations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generate all combinations of n_elements tuples; order is ignored.</span>

<span class="sd">        (&#39;A&#39;,&#39;T&#39;) == (&#39;T&#39;,&#39;A&#39;).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">combinations_with_replacement</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">symbols</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_elements</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_decode_snps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert network output in sample to a set of medaka.vcf.Variants.</span>

<span class="sd">        Recording SNPs but NOT indels.</span>

<span class="sd">        :param sample: medaka.common.Sample</span>

<span class="sd">        :returns: list of medaka.vcf.Variant objects for SNPs</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ref_name</span> <span class="o">=</span> <span class="n">sample</span><span class="o">.</span><span class="n">ref_name</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">sample</span><span class="o">.</span><span class="n">positions</span>
        <span class="n">probs</span> <span class="o">=</span> <span class="n">sample</span><span class="o">.</span><span class="n">label_probs</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref_vcf</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># process (all) loci in ref_vcf</span>
            <span class="n">loci</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="o">.</span><span class="n">pos</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref_vcf</span><span class="o">.</span><span class="n">fetch</span><span class="p">(</span>
                <span class="n">ref_name</span><span class="o">=</span><span class="n">ref_name</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="n">sample</span><span class="o">.</span><span class="n">first_pos</span><span class="p">,</span>
                <span class="n">end</span><span class="o">=</span><span class="n">sample</span><span class="o">.</span><span class="n">end_pos</span><span class="p">)}</span>

            <span class="n">indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
            <span class="n">ref_symbols</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">probs</span><span class="p">)):</span>
                <span class="n">reference_symbol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref_seq</span><span class="p">[</span><span class="n">pos</span><span class="p">[</span><span class="s1">&#39;major&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]]</span>
                <span class="c1"># insertions are ignored</span>
                <span class="c1"># ref_symbol must be in standard set</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">((</span><span class="n">pos</span><span class="p">[</span><span class="s1">&#39;major&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="ow">in</span> <span class="n">loci</span><span class="p">,</span>
                            <span class="n">pos</span><span class="p">[</span><span class="s1">&#39;minor&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span>
                            <span class="n">reference_symbol</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">symbols</span><span class="p">)):</span>
                    <span class="k">continue</span>
                <span class="n">indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">ref_symbols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">reference_symbol</span><span class="p">)</span>

            <span class="n">snps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prob_to_snp</span><span class="p">(</span>
                <span class="n">probs</span><span class="p">[</span><span class="n">indices</span><span class="p">],</span> <span class="n">pos</span><span class="p">[</span><span class="s1">&#39;major&#39;</span><span class="p">][</span><span class="n">indices</span><span class="p">],</span> <span class="n">ref_name</span><span class="p">,</span>
                <span class="n">ref_symbols</span><span class="p">,</span> <span class="n">return_all</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># process all loci but only retain variant loci</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
            <span class="n">ref_symbols</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">probs</span><span class="p">)):</span>
                <span class="n">reference_symbol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref_seq</span><span class="p">[</span><span class="n">pos</span><span class="p">[</span><span class="s1">&#39;major&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">((</span><span class="n">pos</span><span class="p">[</span><span class="s1">&#39;minor&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span>
                            <span class="n">reference_symbol</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">symbols</span><span class="p">)):</span>
                    <span class="k">continue</span>
                <span class="n">indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">ref_symbols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">reference_symbol</span><span class="p">)</span>

            <span class="n">snps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prob_to_snp</span><span class="p">(</span>
                <span class="n">probs</span><span class="p">[</span><span class="n">indices</span><span class="p">],</span> <span class="n">pos</span><span class="p">[</span><span class="s1">&#39;major&#39;</span><span class="p">][</span><span class="n">indices</span><span class="p">],</span> <span class="n">ref_name</span><span class="p">,</span>
                <span class="n">ref_symbols</span><span class="p">,</span> <span class="n">return_all</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">snps</span>

<div class="viewcode-block" id="BaseLabelScheme.decode_snps"><a class="viewcode-back" href="../../medaka.html#medaka.labels.BaseLabelScheme.decode_snps">[docs]</a>    <span class="k">def</span> <span class="nf">decode_snps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample</span><span class="p">,</span> <span class="n">ref_seq</span><span class="p">,</span> <span class="n">ref_vcf</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">0.04</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Decode network outputs to medaka.vcf.Variant objects recording SNPs.</span>

<span class="sd">        Optionally, SNPs are returned at ALL loci specified in suplied ref_vcf.</span>

<span class="sd">        :param sample: `medaka.common.Sample`</span>
<span class="sd">        :param ref_seq: reference sequence, should be upper case.</span>
<span class="sd">        :param ref_vcf: `.vcf` file</span>
<span class="sd">        :param threshold: threshold for acceptance of secondary call.</span>

<span class="sd">        :returns: list of `medaka.vcf.Variant` objects</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ref_seq</span> <span class="o">=</span> <span class="n">ref_seq</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">secondary_threshold</span> <span class="o">=</span> <span class="n">threshold</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ref_vcf</span> <span class="o">=</span> <span class="n">medaka</span><span class="o">.</span><span class="n">vcf</span><span class="o">.</span><span class="n">VCFReader</span><span class="p">(</span><span class="n">ref_vcf</span><span class="p">)</span> \
            <span class="k">if</span> <span class="n">ref_vcf</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decode_snps</span><span class="p">(</span><span class="n">sample</span><span class="p">)</span></div>

    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">_prob_to_snp</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">outputs</span><span class="p">,</span> <span class="n">positions</span><span class="p">,</span> <span class="n">ref_name</span><span class="p">,</span> <span class="n">ref_symbols</span><span class="p">,</span>
            <span class="n">return_all</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert network output to `medaka.common.Variant` s.</span>

<span class="sd">        This method contains all logic for converting network</span>
<span class="sd">        output into SNP Variants.</span>

<span class="sd">        :param outputs: np.ndarray of network outputs</span>
<span class="sd">            for multiple loci</span>
<span class="sd">        :param pos: array of genomic indices</span>
<span class="sd">        :param ref_name: reference name</span>
<span class="sd">        :param ref_symbols: the symbols at ref_seq[pos]</span>
<span class="sd">        :param return_all: return a `medaka.vcf.Variant` even if</span>
<span class="sd">            there is no SNP at a locus.</span>

<span class="sd">        :returns: a list of `medaka.vcf.Variant` s</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">snp_metainfo</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return meta data for use in `.vcf` header.&quot;&quot;&quot;</span>
        <span class="n">MI</span> <span class="o">=</span> <span class="n">medaka</span><span class="o">.</span><span class="n">vcf</span><span class="o">.</span><span class="n">MetaInfo</span>
        <span class="n">m</span> <span class="o">=</span> <span class="p">[</span><span class="n">MI</span><span class="p">(</span><span class="s1">&#39;INFO&#39;</span><span class="p">,</span> <span class="s1">&#39;ref_prob&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;Float&#39;</span><span class="p">,</span>
                <span class="s1">&#39;Medaka probability for reference allele&#39;</span><span class="p">),</span>
             <span class="n">MI</span><span class="p">(</span><span class="s1">&#39;INFO&#39;</span><span class="p">,</span> <span class="s1">&#39;primary_prob&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;Float&#39;</span><span class="p">,</span>
                <span class="s1">&#39;Medaka probability of primary call&#39;</span><span class="p">),</span>
             <span class="n">MI</span><span class="p">(</span><span class="s1">&#39;INFO&#39;</span><span class="p">,</span> <span class="s1">&#39;primary_call&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;String&#39;</span><span class="p">,</span>
                <span class="s1">&#39;Medaka primary call&#39;</span><span class="p">),</span>
             <span class="n">MI</span><span class="p">(</span><span class="s1">&#39;INFO&#39;</span><span class="p">,</span> <span class="s1">&#39;secondary_prob&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;Float&#39;</span><span class="p">,</span>
                <span class="s1">&#39;Medaka probability of secondary call&#39;</span><span class="p">),</span>
             <span class="n">MI</span><span class="p">(</span><span class="s1">&#39;INFO&#39;</span><span class="p">,</span> <span class="s1">&#39;secondary_call&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;String&#39;</span><span class="p">,</span>
                <span class="s1">&#39;Medaka secondary call&#39;</span><span class="p">),</span>
             <span class="n">MI</span><span class="p">(</span><span class="s1">&#39;FORMAT&#39;</span><span class="p">,</span> <span class="s1">&#39;GT&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;String&#39;</span><span class="p">,</span> <span class="s1">&#39;Medaka genotype&#39;</span><span class="p">),</span>
             <span class="n">MI</span><span class="p">(</span><span class="s1">&#39;FORMAT&#39;</span><span class="p">,</span> <span class="s1">&#39;GQ&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;Float&#39;</span><span class="p">,</span> <span class="s1">&#39;Medaka genotype quality score&#39;</span><span class="p">)]</span>

        <span class="k">return</span> <span class="n">m</span></div>


<div class="viewcode-block" id="HaploidLabelScheme"><a class="viewcode-back" href="../../medaka.html#medaka.labels.HaploidLabelScheme">[docs]</a><span class="k">class</span> <span class="nc">HaploidLabelScheme</span><span class="p">(</span><span class="n">BaseLabelScheme</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A single-element label per genomic position.</span>

<span class="sd">    Unitary symbols map to integers, which map to one-hot encoded</span>
<span class="sd">    training vectors.</span>

<span class="sd">    Encoding (&#39;A&#39;,) -&gt; 1 -&gt; [0, 1, 0, 0, 0]</span>

<span class="sd">    Consensus decoding is simple argmax.</span>
<span class="sd">    [[0.02, 0.9, 0.02, 0.01, 0.05], [0.01, 0.02, 0.01, 0.9, 0.05]] -&gt; &quot;AG&quot;</span>

<span class="sd">    SNP decoding utilises a hard threshold to define secondary calls.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_elements</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return number of elements provided by truth alignment.</span>

<span class="sd">        Synonymous with ploidy.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mi">1</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_classes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return number of elements in output layer of neural network.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_decoding</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">padding_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the integer encoding used to denote a gap.&quot;&quot;&quot;</span>
        <span class="n">gap</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;*&#39;</span><span class="p">,)]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_labels_to_encoded_labels</span><span class="p">(</span><span class="n">gap</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="nd">@functools</span><span class="o">.</span><span class="n">lru_cache</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_encoding</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a dictionary mapping from label tuple to integer (tuple).</span>

<span class="sd">        This property is accessed by methods that are responsible</span>
<span class="sd">        for encoding. Also, it can be written to file in order to</span>
<span class="sd">        log the encoding scheme used.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unitary_encoding</span>

    <span class="k">def</span> <span class="nf">_alignment_to_pairs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">aln</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert `pysam.AlignedSegment` to aligned pairs.&quot;&quot;&quot;</span>
        <span class="n">seq</span> <span class="o">=</span> <span class="n">aln</span><span class="o">.</span><span class="n">query_sequence</span>
        <span class="k">for</span> <span class="n">qpos</span><span class="p">,</span> <span class="n">rpos</span> <span class="ow">in</span> <span class="n">aln</span><span class="o">.</span><span class="n">get_aligned_pairs</span><span class="p">():</span>
            <span class="k">yield</span> <span class="n">rpos</span><span class="p">,</span> <span class="n">seq</span><span class="p">[</span><span class="n">qpos</span><span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="k">if</span> <span class="n">qpos</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="s1">&#39;*&#39;</span>

    <span class="k">def</span> <span class="nf">_labels_to_encoded_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert list of label tuples to array of integer encoded labels.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">fromiter</span><span class="p">(</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_encoding</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

<div class="viewcode-block" id="HaploidLabelScheme.encoded_labels_to_training_vectors"><a class="viewcode-back" href="../../medaka.html#medaka.labels.HaploidLabelScheme.encoded_labels_to_training_vectors">[docs]</a>    <span class="k">def</span> <span class="nf">encoded_labels_to_training_vectors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">enc_labels</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert integer (tuple) encoded labels to truth vectors.</span>

<span class="sd">        (e.g. sparse one-hot encoded truth vectors) that represent the truth</span>
<span class="sd">        for comparison with network output logits in</span>
<span class="sd">        e.g. metric(truth, pred) or loss(truth, pred)) functions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO remove once legacy files extinct.</span>
        <span class="c1"># legacy features had (base, runlength) with the encoding:</span>
        <span class="c1"># gap, lowercase bases, uppercase bases, other stuff</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">enc_labels</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">enc_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">4</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">enc_labels</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;int64&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">enc_labels</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># sparse 1-hot</span></div>

    <span class="k">def</span> <span class="nf">_prob_to_snp</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">outputs</span><span class="p">,</span> <span class="n">positions</span><span class="p">,</span> <span class="n">ref_name</span><span class="p">,</span> <span class="n">ref_symbols</span><span class="p">,</span>
            <span class="n">return_all</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert networkout output to `medaka.common.Variant` s.</span>

<span class="sd">        A threshold is used to define significant secondary calls</span>
<span class="sd">        allowing the prediciton of homozygous and heterozygous</span>
<span class="sd">        diploid calls.</span>

<span class="sd">        Where a significant secondary call is a deletion, the</span>
<span class="sd">        SNP is considered homozygous in the primary call.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">results</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">network_output</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">ref_symbol</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                <span class="n">outputs</span><span class="p">,</span> <span class="n">positions</span><span class="p">,</span> <span class="n">ref_symbols</span><span class="p">):</span>
            <span class="c1"># TODO: some optimisation here?</span>
            <span class="n">secondary_call</span><span class="p">,</span> <span class="n">primary_call</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_decoding</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">network_output</span><span class="p">)[</span><span class="o">-</span><span class="mi">2</span><span class="p">:])</span>

            <span class="n">secondary_prob</span><span class="p">,</span> <span class="n">primary_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">network_output</span><span class="p">)[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span>
            <span class="n">ref_prob</span> <span class="o">=</span> <span class="n">network_output</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_encoding</span><span class="p">[(</span><span class="n">ref_symbol</span><span class="p">,)]]</span>

            <span class="n">info</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;ref_prob&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pfmt</span><span class="p">(</span><span class="n">ref_prob</span><span class="p">),</span>
                <span class="s1">&#39;primary_prob&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pfmt</span><span class="p">(</span><span class="n">primary_prob</span><span class="p">),</span>
                <span class="s1">&#39;primary_call&#39;</span><span class="p">:</span> <span class="n">primary_call</span><span class="p">,</span>
                <span class="s1">&#39;secondary_prob&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pfmt</span><span class="p">(</span><span class="n">secondary_prob</span><span class="p">),</span>
                <span class="s1">&#39;secondary_call&#39;</span><span class="p">:</span> <span class="n">secondary_call</span><span class="p">}</span>

            <span class="c1"># logical tests</span>
            <span class="n">primary_is_reference</span> <span class="o">=</span> <span class="n">primary_call</span> <span class="o">==</span> <span class="n">ref_symbol</span>
            <span class="n">primary_is_deletion</span> <span class="o">=</span> <span class="n">primary_call</span> <span class="o">==</span> <span class="s1">&#39;*&#39;</span>
            <span class="n">secondary_is_deletion</span> <span class="o">=</span> <span class="n">secondary_call</span> <span class="o">==</span> <span class="s1">&#39;*&#39;</span>
            <span class="n">secondary_exceeds_threshold</span> <span class="o">=</span> \
                <span class="n">secondary_prob</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">secondary_threshold</span>

            <span class="c1"># homozygous snp</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">((</span><span class="ow">not</span> <span class="n">primary_is_reference</span><span class="p">,</span>
                    <span class="ow">not</span> <span class="n">primary_is_deletion</span><span class="p">,</span>
                    <span class="ow">not</span> <span class="n">secondary_exceeds_threshold</span><span class="p">)):</span>

                <span class="n">alt</span> <span class="o">=</span> <span class="n">primary_call</span>
                <span class="n">qual</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pfmt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_phred</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">primary_prob</span><span class="p">))</span>
                <span class="n">genotype</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;GT&#39;</span><span class="p">:</span> <span class="s1">&#39;1/1&#39;</span><span class="p">,</span> <span class="s1">&#39;GQ&#39;</span><span class="p">:</span> <span class="n">qual</span><span class="p">}</span>
                <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">medaka</span><span class="o">.</span><span class="n">vcf</span><span class="o">.</span><span class="n">Variant</span><span class="p">(</span>
                    <span class="n">ref_name</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">ref_symbol</span><span class="p">,</span> <span class="n">alt</span><span class="p">,</span> <span class="n">filt</span><span class="o">=</span><span class="s1">&#39;PASS&#39;</span><span class="p">,</span> <span class="n">info</span><span class="o">=</span><span class="n">info</span><span class="p">,</span>
                    <span class="n">qual</span><span class="o">=</span><span class="n">qual</span><span class="p">,</span> <span class="n">genotype_data</span><span class="o">=</span><span class="n">genotype</span><span class="p">))</span>

            <span class="c1"># heterozygous, no deletions</span>
            <span class="k">elif</span> <span class="nb">all</span><span class="p">((</span><span class="ow">not</span> <span class="n">primary_is_deletion</span><span class="p">,</span>
                      <span class="ow">not</span> <span class="n">secondary_is_deletion</span><span class="p">,</span>
                      <span class="n">secondary_exceeds_threshold</span><span class="p">)):</span>

                <span class="n">err</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">primary_prob</span> <span class="o">+</span> <span class="n">secondary_prob</span><span class="p">)</span>
                <span class="n">qual</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pfmt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_phred</span><span class="p">(</span><span class="n">err</span><span class="p">))</span>
                <span class="c1"># filtering by list comp maintains order</span>
                <span class="n">alt</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="p">[</span><span class="n">primary_call</span><span class="p">,</span> <span class="n">secondary_call</span><span class="p">]</span>
                       <span class="k">if</span> <span class="ow">not</span> <span class="n">c</span> <span class="o">==</span> <span class="n">ref_symbol</span><span class="p">]</span>
                <span class="n">gt</span> <span class="o">=</span> <span class="s1">&#39;0/1&#39;</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">alt</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="s1">&#39;1/2&#39;</span>
                <span class="n">genotype</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;GT&#39;</span><span class="p">:</span> <span class="n">gt</span><span class="p">,</span> <span class="s1">&#39;GQ&#39;</span><span class="p">:</span> <span class="n">qual</span><span class="p">}</span>

                <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">medaka</span><span class="o">.</span><span class="n">vcf</span><span class="o">.</span><span class="n">Variant</span><span class="p">(</span>
                    <span class="n">ref_name</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">ref_symbol</span><span class="p">,</span> <span class="n">alt</span><span class="p">,</span> <span class="n">filt</span><span class="o">=</span><span class="s1">&#39;PASS&#39;</span><span class="p">,</span>
                    <span class="n">info</span><span class="o">=</span><span class="n">info</span><span class="p">,</span> <span class="n">qual</span><span class="o">=</span><span class="n">qual</span><span class="p">,</span> <span class="n">genotype_data</span><span class="o">=</span><span class="n">genotype</span><span class="p">))</span>

            <span class="c1"># heterozygous, secondary deletion</span>
            <span class="k">elif</span> <span class="nb">all</span><span class="p">((</span><span class="ow">not</span> <span class="n">primary_is_reference</span><span class="p">,</span>
                      <span class="ow">not</span> <span class="n">primary_is_deletion</span><span class="p">,</span>
                      <span class="n">secondary_is_deletion</span><span class="p">,</span>
                      <span class="n">secondary_exceeds_threshold</span><span class="p">)):</span>

                <span class="n">alt</span> <span class="o">=</span> <span class="n">primary_call</span>
                <span class="n">qual</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pfmt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_phred</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">primary_prob</span><span class="p">))</span>
                <span class="n">genotype</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;GT&#39;</span><span class="p">:</span> <span class="s1">&#39;1/1&#39;</span><span class="p">,</span> <span class="s1">&#39;GQ&#39;</span><span class="p">:</span> <span class="n">qual</span><span class="p">}</span>
                <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">medaka</span><span class="o">.</span><span class="n">vcf</span><span class="o">.</span><span class="n">Variant</span><span class="p">(</span>
                    <span class="n">ref_name</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">ref_symbol</span><span class="p">,</span> <span class="n">alt</span><span class="p">,</span> <span class="n">filt</span><span class="o">=</span><span class="s1">&#39;PASS&#39;</span><span class="p">,</span>
                    <span class="n">info</span><span class="o">=</span><span class="n">info</span><span class="p">,</span> <span class="n">qual</span><span class="o">=</span><span class="n">qual</span><span class="p">,</span> <span class="n">genotype_data</span><span class="o">=</span><span class="n">genotype</span><span class="p">))</span>

            <span class="c1"># no snp at this location</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">return_all</span><span class="p">:</span>
                    <span class="c1"># return variant even though it is not a snp</span>
                    <span class="n">qual</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pfmt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_phred</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">primary_prob</span><span class="p">))</span>
                    <span class="n">genotype</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;GT&#39;</span><span class="p">:</span> <span class="s1">&#39;0/0&#39;</span><span class="p">,</span> <span class="s1">&#39;GQ&#39;</span><span class="p">:</span> <span class="n">qual</span><span class="p">}</span>
                    <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">medaka</span><span class="o">.</span><span class="n">vcf</span><span class="o">.</span><span class="n">Variant</span><span class="p">(</span>
                        <span class="n">ref_name</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">ref_symbol</span><span class="p">,</span> <span class="n">alt</span><span class="o">=</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="n">filt</span><span class="o">=</span><span class="s1">&#39;PASS&#39;</span><span class="p">,</span>
                        <span class="n">info</span><span class="o">=</span><span class="n">info</span><span class="p">,</span> <span class="n">qual</span><span class="o">=</span><span class="n">qual</span><span class="p">,</span> <span class="n">genotype_data</span><span class="o">=</span><span class="n">genotype</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">results</span>

<div class="viewcode-block" id="HaploidLabelScheme.decode_variants"><a class="viewcode-back" href="../../medaka.html#medaka.labels.HaploidLabelScheme.decode_variants">[docs]</a>    <span class="k">def</span> <span class="nf">decode_variants</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample</span><span class="p">,</span> <span class="n">ref_seq</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert network output in sample to a set of `medaka.vcf.Variant` s.</span>

<span class="sd">        A consensus sequence is decoded and compared with a reference sequence.</span>
<span class="sd">        Both substitution and indel variants that may be multi-base will be</span>
<span class="sd">        reported in the output `medaka.vcf.Variant` s.</span>

<span class="sd">        :param sample: `medaka.common.Sample`.</span>
<span class="sd">        :param ref_seq: reference sequence, should be upper case.</span>

<span class="sd">        :returns: list of `medaka.vcf.Variant` objects.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">sample</span><span class="o">.</span><span class="n">positions</span>
        <span class="n">probs</span> <span class="o">=</span> <span class="n">sample</span><span class="o">.</span><span class="n">label_probs</span>

        <span class="k">assert</span> <span class="n">sample</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="s1">&#39;minor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span>

        <span class="c1"># array of symbols retaining gaps</span>
        <span class="n">predicted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">decode_consensus</span><span class="p">(</span><span class="n">sample</span><span class="p">,</span> <span class="n">with_gaps</span><span class="o">=</span><span class="kc">True</span><span class="p">)))</span>

        <span class="c1"># get reference sequence with insertions marked as &#39;*&#39;</span>

        <span class="k">def</span> <span class="nf">get_symbol</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">ref_seq</span><span class="p">[</span><span class="n">p</span><span class="p">[</span><span class="s1">&#39;major&#39;</span><span class="p">]]</span> <span class="k">if</span> <span class="n">p</span><span class="p">[</span><span class="s1">&#39;minor&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="s1">&#39;*&#39;</span>

        <span class="n">reference</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromiter</span><span class="p">((</span><span class="n">get_symbol</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pos</span><span class="p">),</span>
                                <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;|U1&#39;</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">pos</span><span class="p">))</span>

        <span class="c1"># find variants by looking for runs of labels which differ.</span>
        <span class="c1"># If both labels are gap, we don&#39;t want to consider this a</span>
        <span class="c1"># match so as to avoid splitting up long insertions if</span>
        <span class="c1"># there happens to be a gap label in ref and pred.</span>
        <span class="n">mismatch</span> <span class="o">=</span> <span class="n">predicted</span> <span class="o">!=</span> <span class="n">reference</span>
        <span class="n">both_gap</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">predicted</span> <span class="o">==</span> <span class="s1">&#39;*&#39;</span><span class="p">,</span>
                                  <span class="n">reference</span> <span class="o">==</span> <span class="s1">&#39;*&#39;</span><span class="p">)</span>
        <span class="n">is_variant</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">mismatch</span><span class="p">,</span> <span class="n">both_gap</span><span class="p">)</span>

        <span class="c1"># medaka.common.rle requires numeric input</span>
        <span class="n">runs</span> <span class="o">=</span> <span class="n">medaka</span><span class="o">.</span><span class="n">rle</span><span class="o">.</span><span class="n">rle</span><span class="p">(</span><span class="n">is_variant</span><span class="p">)</span>
        <span class="n">variant_runs</span> <span class="o">=</span> <span class="n">runs</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">runs</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">])]</span>
        <span class="n">variants</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">encoding</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_encoding</span>
        <span class="k">for</span> <span class="n">run</span> <span class="ow">in</span> <span class="n">variant_runs</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">run</span><span class="p">[</span><span class="s1">&#39;start&#39;</span><span class="p">]</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">run</span><span class="p">[</span><span class="s1">&#39;length&#39;</span><span class="p">]</span>
            <span class="c1"># if call or ref starts with gap, pad left</span>
            <span class="c1"># (or right if we are at start of genome).</span>
            <span class="n">pad_right</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">while</span> <span class="p">((</span><span class="ow">not</span> <span class="n">pad_right</span> <span class="ow">and</span>
                    <span class="p">(</span><span class="n">reference</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;*&#39;</span> <span class="ow">or</span>
                     <span class="n">predicted</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;*&#39;</span><span class="p">))</span>
                   <span class="ow">or</span>
                   <span class="p">(</span><span class="n">pad_right</span> <span class="ow">and</span>
                    <span class="p">(</span><span class="n">reference</span><span class="p">[</span><span class="n">end</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;*&#39;</span> <span class="ow">or</span>
                     <span class="n">predicted</span><span class="p">[</span><span class="n">end</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;*&#39;</span><span class="p">))):</span>

                <span class="k">if</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="n">start</span><span class="p">])</span> <span class="o">==</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="n">pad_right</span><span class="p">:</span>
                    <span class="n">end</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="c1"># avoid getting stuck in loop if there is a run</span>
                    <span class="c1"># of dels at start of ref</span>
                    <span class="n">pad_right</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="n">start</span> <span class="o">!=</span> <span class="mi">0</span>
                    <span class="n">start</span> <span class="o">-=</span> <span class="mi">1</span>

            <span class="n">var_ref_with_gaps</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">reference</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">])</span>
            <span class="n">var_ref</span> <span class="o">=</span> <span class="n">var_ref_with_gaps</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>

            <span class="n">var_pred_with_gaps</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">predicted</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">])</span>
            <span class="n">var_pred</span> <span class="o">=</span> <span class="n">var_pred_with_gaps</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">var_ref</span> <span class="o">==</span> <span class="n">var_pred</span><span class="p">:</span>
                <span class="c1"># not a variant</span>
                <span class="k">continue</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="nb">set</span><span class="p">(</span><span class="n">var_ref</span><span class="p">)</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">symbols</span><span class="p">)):</span>
                <span class="c1"># don&#39;t call where reference is ambiguous</span>
                <span class="k">continue</span>

            <span class="n">var_probs</span> <span class="o">=</span> <span class="n">probs</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span>

            <span class="n">var_ref_encoded</span> <span class="o">=</span> <span class="p">(</span><span class="n">encoding</span><span class="p">[(</span><span class="n">s</span><span class="p">,)]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">var_ref_with_gaps</span><span class="p">)</span>
            <span class="n">var_pred_encoded</span> <span class="o">=</span> <span class="p">(</span><span class="n">encoding</span><span class="p">[(</span><span class="n">s</span><span class="p">,)]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">var_pred_with_gaps</span><span class="p">)</span>

            <span class="n">ref_probs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">var_probs</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
                                 <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">var_ref_encoded</span><span class="p">)])</span>
            <span class="n">pred_probs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">var_probs</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
                                  <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">var_pred_encoded</span><span class="p">)])</span>

            <span class="n">ref_quals</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_phred</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">ref_probs</span><span class="p">]</span>
            <span class="n">pred_quals</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_phred</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pred_probs</span><span class="p">]</span>

            <span class="n">info</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;ref_seq&#39;</span><span class="p">:</span> <span class="n">var_ref_with_gaps</span><span class="p">,</span>
                    <span class="s1">&#39;pred_seq&#39;</span><span class="p">:</span> <span class="n">var_pred_with_gaps</span><span class="p">,</span>
                    <span class="s1">&#39;ref_qs&#39;</span><span class="p">:</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_pfmt</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">ref_quals</span><span class="p">)),</span>
                    <span class="s1">&#39;pred_qs&#39;</span><span class="p">:</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_pfmt</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">pred_quals</span><span class="p">)),</span>
                    <span class="s1">&#39;ref_q&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pfmt</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">ref_quals</span><span class="p">)),</span>
                    <span class="s1">&#39;pred_q&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pfmt</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">pred_quals</span><span class="p">)),</span>
                    <span class="s1">&#39;n_cols&#39;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">pred_quals</span><span class="p">)}</span>

            <span class="c1"># log likelihood ratio</span>
            <span class="n">qual</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pfmt</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">pred_quals</span><span class="p">)</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">(</span><span class="n">ref_quals</span><span class="p">))</span>
            <span class="n">genotype</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;GT&#39;</span><span class="p">:</span> <span class="s1">&#39;1/1&#39;</span><span class="p">,</span> <span class="s1">&#39;GQ&#39;</span><span class="p">:</span> <span class="n">qual</span><span class="p">}</span>

            <span class="n">variant</span> <span class="o">=</span> <span class="n">medaka</span><span class="o">.</span><span class="n">vcf</span><span class="o">.</span><span class="n">Variant</span><span class="p">(</span><span class="n">sample</span><span class="o">.</span><span class="n">ref_name</span><span class="p">,</span>
                                         <span class="n">pos</span><span class="p">[</span><span class="s1">&#39;major&#39;</span><span class="p">][</span><span class="n">start</span><span class="p">],</span>
                                         <span class="n">var_ref</span><span class="p">,</span> <span class="n">alt</span><span class="o">=</span><span class="n">var_pred</span><span class="p">,</span>
                                         <span class="n">filt</span><span class="o">=</span><span class="s1">&#39;PASS&#39;</span><span class="p">,</span> <span class="n">info</span><span class="o">=</span><span class="n">info</span><span class="p">,</span>
                                         <span class="n">qual</span><span class="o">=</span><span class="n">qual</span><span class="p">,</span> <span class="n">genotype_data</span><span class="o">=</span><span class="n">genotype</span><span class="p">)</span>
            <span class="n">variant</span> <span class="o">=</span> <span class="n">variant</span><span class="o">.</span><span class="n">trim</span><span class="p">()</span>
            <span class="n">variants</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">variant</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">variants</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">variant_metainfo</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return meta data for use in `.vcf` header.&quot;&quot;&quot;</span>
        <span class="n">MI</span> <span class="o">=</span> <span class="n">medaka</span><span class="o">.</span><span class="n">vcf</span><span class="o">.</span><span class="n">MetaInfo</span>
        <span class="n">m</span> <span class="o">=</span> <span class="p">[</span><span class="n">MI</span><span class="p">(</span><span class="s1">&#39;INFO&#39;</span><span class="p">,</span> <span class="s1">&#39;ref_seq&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;String&#39;</span><span class="p">,</span>
                <span class="s1">&#39;Medaka reference sequence&#39;</span><span class="p">),</span>
             <span class="n">MI</span><span class="p">(</span><span class="s1">&#39;INFO&#39;</span><span class="p">,</span> <span class="s1">&#39;pred_seq&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;String&#39;</span><span class="p">,</span>
                <span class="s1">&#39;Medaka predicted sequence&#39;</span><span class="p">),</span>
             <span class="n">MI</span><span class="p">(</span><span class="s1">&#39;INFO&#39;</span><span class="p">,</span> <span class="s1">&#39;ref_qs&#39;</span><span class="p">,</span> <span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="s1">&#39;Float&#39;</span><span class="p">,</span>
                <span class="s1">&#39;Medaka quality score for reference&#39;</span><span class="p">),</span>
             <span class="n">MI</span><span class="p">(</span><span class="s1">&#39;INFO&#39;</span><span class="p">,</span> <span class="s1">&#39;pred_qs&#39;</span><span class="p">,</span> <span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="s1">&#39;Float&#39;</span><span class="p">,</span>
                <span class="s1">&#39;Medaka quality score for prediction&#39;</span><span class="p">),</span>
             <span class="n">MI</span><span class="p">(</span><span class="s1">&#39;INFO&#39;</span><span class="p">,</span> <span class="s1">&#39;ref_q&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;Float&#39;</span><span class="p">,</span>
                <span class="s1">&#39;Medaka per position quality score for reference&#39;</span><span class="p">),</span>
             <span class="n">MI</span><span class="p">(</span><span class="s1">&#39;INFO&#39;</span><span class="p">,</span> <span class="s1">&#39;pred_q&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;Float&#39;</span><span class="p">,</span>
                <span class="s1">&#39;Medaka per position quality score for prediction&#39;</span><span class="p">),</span>
             <span class="n">MI</span><span class="p">(</span><span class="s1">&#39;FORMAT&#39;</span><span class="p">,</span> <span class="s1">&#39;GT&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;String&#39;</span><span class="p">,</span>
                <span class="s1">&#39;Medaka genotype.&#39;</span><span class="p">),</span>
             <span class="n">MI</span><span class="p">(</span><span class="s1">&#39;FORMAT&#39;</span><span class="p">,</span> <span class="s1">&#39;GQ&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;Float&#39;</span><span class="p">,</span>
                <span class="s1">&#39;Medaka genotype quality score&#39;</span><span class="p">),</span>
             <span class="n">MI</span><span class="p">(</span><span class="s1">&#39;INFO&#39;</span><span class="p">,</span> <span class="s1">&#39;n_cols&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;Integer&#39;</span><span class="p">,</span>
                <span class="s1">&#39;Number of medaka pileup columns in variant call&#39;</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">m</span>

<div class="viewcode-block" id="HaploidLabelScheme.decode_consensus"><a class="viewcode-back" href="../../medaka.html#medaka.labels.HaploidLabelScheme.decode_consensus">[docs]</a>    <span class="k">def</span> <span class="nf">decode_consensus</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample</span><span class="p">,</span> <span class="n">with_gaps</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert network output to consensus sequence by argmax decoding.</span>

<span class="sd">        :param sample: medaka.common.Sample</span>
<span class="sd">        :param with_gaps: include gap (&quot;*&quot;) characters in output.</span>

<span class="sd">        :returns: str, consensus sequence</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># property access is slow</span>
        <span class="n">decode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decoding</span>
        <span class="c1"># most probable class</span>
        <span class="n">mp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">sample</span><span class="o">.</span><span class="n">label_probs</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">seq</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">((</span><span class="n">decode</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">mp</span><span class="p">))</span>
        <span class="c1"># delete gap symbol from sequence</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">with_gaps</span><span class="p">:</span>
            <span class="n">seq</span> <span class="o">=</span> <span class="n">seq</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">seq</span></div></div>


<div class="viewcode-block" id="DiploidLabelScheme"><a class="viewcode-back" href="../../medaka.html#medaka.labels.DiploidLabelScheme">[docs]</a><span class="k">class</span> <span class="nc">DiploidLabelScheme</span><span class="p">(</span><span class="n">BaseLabelScheme</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;LabelScheme defines a two-element label per genomic position.</span>

<span class="sd">    Each label maps to an integer, and we make a direct diploid call.</span>
<span class="sd">    A categorical crossentropy loss is appropriate.</span>

<span class="sd">    Encoding: (&#39;A&#39;, &#39;C&#39;) -&gt; 6 -&gt; [6] (a sparse one-hot encoded training vector)</span>

<span class="sd">    SNP decoding: [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0] -&gt; (&#39;A&#39;, &#39;C&#39;)</span>
<span class="sd">    (network output is not constrained to be 0 or 1, but for simplicity</span>
<span class="sd">    we show the argmax probability as 1 and all others as 0)</span>

<span class="sd">    Depending on the reference, this may result in a homozygous or</span>
<span class="sd">    heterozygous SNP call.</span>

<span class="sd">    Where reference is (&#39;A&#39;,), we output ref=&#39;A&#39;, alt=[&#39;C&#39;], GT=&#39;0/1&#39;</span>
<span class="sd">    Where reference is (&#39;T&#39;,), we output ref=&#39;T&#39; alt=[&#39;A&#39;, &#39;C&#39;], GT=&#39;1/2&#39;</span>

<span class="sd">    When predicion is homozygous e.g. (&#39;A&#39;, &#39;A&#39;):</span>
<span class="sd">    Where reference is (&#39;T&#39;,), we output ref=&#39;T&#39;, alt=[&#39;A&#39;], GT=&#39;1/1&#39;</span>

<span class="sd">    When the prediction contains a gap symbol e.g. (&#39;A&#39;, &#39;*&#39;):</span>
<span class="sd">    Where reference is (&#39;T&#39;,), we output ref=&#39;T&#39;, alt=[&#39;A&#39;], GT=&#39;1/1&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_elements</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return number of elements provided by truth alignment.</span>

<span class="sd">        Synonymous with ploidy.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mi">2</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_classes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return number of elements in output layer of neural network.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_decoding</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">padding_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the integer encoding used to denote a gap.&quot;&quot;&quot;</span>
        <span class="n">gap</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="s1">&#39;*&#39;</span><span class="p">)]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_labels_to_encoded_labels</span><span class="p">(</span><span class="n">gap</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="nd">@functools</span><span class="o">.</span><span class="n">lru_cache</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_encoding</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_unordered_label_combinations</span><span class="p">())}</span>

    <span class="k">def</span> <span class="nf">_alignment_to_pairs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">aln</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert `pysam.AlignedSegment` to aligned pairs.&quot;&quot;&quot;</span>
        <span class="n">seq</span> <span class="o">=</span> <span class="n">aln</span><span class="o">.</span><span class="n">query_sequence</span>
        <span class="k">for</span> <span class="n">qpos</span><span class="p">,</span> <span class="n">rpos</span> <span class="ow">in</span> <span class="n">aln</span><span class="o">.</span><span class="n">get_aligned_pairs</span><span class="p">():</span>
            <span class="k">yield</span> <span class="n">rpos</span><span class="p">,</span> <span class="n">seq</span><span class="p">[</span><span class="n">qpos</span><span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="k">if</span> <span class="n">qpos</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="s1">&#39;*&#39;</span>

    <span class="k">def</span> <span class="nf">_labels_to_encoded_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert a list of labels to array of integer encoded labels.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">fromiter</span><span class="p">(</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_encoding</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">x</span><span class="p">))]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

<div class="viewcode-block" id="DiploidLabelScheme.encoded_labels_to_training_vectors"><a class="viewcode-back" href="../../medaka.html#medaka.labels.DiploidLabelScheme.encoded_labels_to_training_vectors">[docs]</a>    <span class="k">def</span> <span class="nf">encoded_labels_to_training_vectors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">enc_labels</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert integer (tuple) encoded labels to truth vectors.</span>

<span class="sd">        (e.g. sparse one-hot encoded truth vectors) that represent the truth</span>
<span class="sd">        for comparison with network output logits in</span>
<span class="sd">        e.g. metric(truth, pred) or loss(truth, pred)) functions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">enc_labels</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># sparse 1-hot</span></div>

    <span class="k">def</span> <span class="nf">_prob_to_snp</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">outputs</span><span class="p">,</span> <span class="n">positions</span><span class="p">,</span> <span class="n">ref_name</span><span class="p">,</span>
            <span class="n">ref_symbols</span><span class="p">,</span> <span class="n">return_all</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert network output single locus to medaka.common.Variant.&quot;&quot;&quot;</span>
        <span class="n">argmax</span> <span class="o">=</span> <span class="n">outputs</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">probs</span> <span class="o">=</span> <span class="n">outputs</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">outputs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">argmax</span><span class="p">]</span>
        <span class="n">quals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_phred</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">probs</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">_make_info</span><span class="p">(</span><span class="n">rs</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
            <span class="c1"># helper for variant info formating</span>
            <span class="n">rp</span> <span class="o">=</span> <span class="n">network_output</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_encoding</span><span class="p">[(</span><span class="n">rs</span><span class="p">,</span> <span class="n">rs</span><span class="p">)]]</span>
            <span class="n">info</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;ref_prob&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pfmt</span><span class="p">(</span><span class="n">rp</span><span class="p">),</span> <span class="s1">&#39;prob&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pfmt</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="s1">&#39;call&#39;</span><span class="p">:</span> <span class="n">c</span><span class="p">}</span>
            <span class="k">return</span> <span class="n">info</span>

        <span class="n">results</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="n">data</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">outputs</span><span class="p">,</span> <span class="n">argmax</span><span class="p">,</span> <span class="n">probs</span><span class="p">,</span> <span class="n">quals</span><span class="p">,</span> <span class="n">positions</span><span class="p">,</span> <span class="n">ref_symbols</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">network_output</span><span class="p">,</span> <span class="n">amax</span><span class="p">,</span> <span class="n">prob</span><span class="p">,</span> <span class="n">qual</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">ref_symbol</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
            <span class="n">call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decoding</span><span class="p">[</span><span class="n">amax</span><span class="p">]</span>

            <span class="c1"># notes: we output only variants with one or more substitutions,</span>
            <span class="c1">#        and deletions are masked from the records. TODO: is this</span>
            <span class="c1">#        really the behaviour we want?</span>
            <span class="k">if</span> <span class="n">call</span> <span class="o">==</span> <span class="p">(</span><span class="n">ref_symbol</span><span class="p">,</span> <span class="n">ref_symbol</span><span class="p">):</span>  <span class="c1"># is reference</span>
                <span class="k">if</span> <span class="n">return_all</span><span class="p">:</span>
                    <span class="c1"># return variant even though it is not a snp</span>
                    <span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pfmt</span><span class="p">(</span><span class="n">qual</span><span class="p">)</span>
                    <span class="n">genotype</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;GT&#39;</span><span class="p">:</span> <span class="s1">&#39;0/0&#39;</span><span class="p">,</span> <span class="s1">&#39;GQ&#39;</span><span class="p">:</span> <span class="n">q</span><span class="p">}</span>
                    <span class="n">info</span> <span class="o">=</span> <span class="n">_make_info</span><span class="p">(</span><span class="n">ref_symbol</span><span class="p">,</span> <span class="n">prob</span><span class="p">,</span> <span class="n">call</span><span class="p">)</span>
                    <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">medaka</span><span class="o">.</span><span class="n">vcf</span><span class="o">.</span><span class="n">Variant</span><span class="p">(</span>
                        <span class="n">ref_name</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">ref_symbol</span><span class="p">,</span> <span class="n">alt</span><span class="o">=</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="n">filt</span><span class="o">=</span><span class="s1">&#39;PASS&#39;</span><span class="p">,</span>
                        <span class="n">info</span><span class="o">=</span><span class="n">info</span><span class="p">,</span> <span class="n">qual</span><span class="o">=</span><span class="n">q</span><span class="p">,</span> <span class="n">genotype_data</span><span class="o">=</span><span class="n">genotype</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># is variant</span>
                <span class="n">contains_deletion</span> <span class="o">=</span> <span class="s1">&#39;*&#39;</span> <span class="ow">in</span> <span class="n">call</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_singleton</span><span class="p">(</span><span class="n">call</span><span class="p">):</span>  <span class="c1"># heterozygous</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">contains_deletion</span><span class="p">:</span>
                        <span class="n">alt</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">call</span> <span class="k">if</span> <span class="n">s</span> <span class="o">!=</span> <span class="n">ref_symbol</span><span class="p">]</span>
                        <span class="n">gt</span> <span class="o">=</span> <span class="s1">&#39;0/1&#39;</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">alt</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="s1">&#39;1/2&#39;</span>
                        <span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pfmt</span><span class="p">(</span><span class="n">qual</span><span class="p">)</span>
                        <span class="n">genotype</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;GT&#39;</span><span class="p">:</span> <span class="n">gt</span><span class="p">,</span> <span class="s1">&#39;GQ&#39;</span><span class="p">:</span> <span class="n">q</span><span class="p">}</span>
                        <span class="n">info</span> <span class="o">=</span> <span class="n">_make_info</span><span class="p">(</span><span class="n">ref_symbol</span><span class="p">,</span> <span class="n">prob</span><span class="p">,</span> <span class="n">call</span><span class="p">)</span>
                        <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">medaka</span><span class="o">.</span><span class="n">vcf</span><span class="o">.</span><span class="n">Variant</span><span class="p">(</span>
                            <span class="n">ref_name</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">ref_symbol</span><span class="p">,</span> <span class="n">alt</span><span class="p">,</span> <span class="n">filt</span><span class="o">=</span><span class="s1">&#39;PASS&#39;</span><span class="p">,</span>
                            <span class="n">info</span><span class="o">=</span><span class="n">info</span><span class="p">,</span> <span class="n">qual</span><span class="o">=</span><span class="n">q</span><span class="p">,</span> <span class="n">genotype_data</span><span class="o">=</span><span class="n">genotype</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>  <span class="c1"># with deletion</span>
                        <span class="c1"># disallow (ref, *), and record (alt, *) as (alt, alt)</span>
                        <span class="n">contains_nonref_nondel</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span>
                            <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">call</span>
                                <span class="k">if</span> <span class="n">s</span> <span class="o">!=</span> <span class="n">ref_symbol</span> <span class="ow">and</span> <span class="n">s</span> <span class="o">!=</span> <span class="s1">&#39;*&#39;</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span>
                        <span class="k">if</span> <span class="n">contains_nonref_nondel</span><span class="p">:</span>
                            <span class="n">alt</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">call</span> <span class="k">if</span> <span class="n">s</span> <span class="o">!=</span> <span class="s1">&#39;*&#39;</span><span class="p">]</span>
                            <span class="n">gt</span> <span class="o">=</span> <span class="s1">&#39;1/1&#39;</span>
                            <span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pfmt</span><span class="p">(</span><span class="n">qual</span><span class="p">)</span>
                            <span class="n">genotype</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;GT&#39;</span><span class="p">:</span> <span class="n">gt</span><span class="p">,</span> <span class="s1">&#39;GQ&#39;</span><span class="p">:</span> <span class="n">q</span><span class="p">}</span>
                            <span class="n">info</span> <span class="o">=</span> <span class="n">_make_info</span><span class="p">(</span><span class="n">ref_symbol</span><span class="p">,</span> <span class="n">prob</span><span class="p">,</span> <span class="n">call</span><span class="p">)</span>
                            <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">medaka</span><span class="o">.</span><span class="n">vcf</span><span class="o">.</span><span class="n">Variant</span><span class="p">(</span>
                                <span class="n">ref_name</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">ref_symbol</span><span class="p">,</span> <span class="n">alt</span><span class="p">,</span> <span class="n">filt</span><span class="o">=</span><span class="s1">&#39;PASS&#39;</span><span class="p">,</span>
                                <span class="n">info</span><span class="o">=</span><span class="n">info</span><span class="p">,</span> <span class="n">qual</span><span class="o">=</span><span class="n">q</span><span class="p">,</span> <span class="n">genotype_data</span><span class="o">=</span><span class="n">genotype</span><span class="p">))</span>
                <span class="k">elif</span> <span class="ow">not</span> <span class="n">contains_deletion</span><span class="p">:</span>  <span class="c1"># homozygous (alt, alt)</span>
                    <span class="n">alt</span> <span class="o">=</span> <span class="n">call</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pfmt</span><span class="p">(</span><span class="n">qual</span><span class="p">)</span>
                    <span class="n">genotype</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;GT&#39;</span><span class="p">:</span> <span class="s1">&#39;1/1&#39;</span><span class="p">,</span> <span class="s1">&#39;GQ&#39;</span><span class="p">:</span> <span class="n">q</span><span class="p">}</span>
                    <span class="n">info</span> <span class="o">=</span> <span class="n">_make_info</span><span class="p">(</span><span class="n">ref_symbol</span><span class="p">,</span> <span class="n">prob</span><span class="p">,</span> <span class="n">call</span><span class="p">)</span>
                    <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">medaka</span><span class="o">.</span><span class="n">vcf</span><span class="o">.</span><span class="n">Variant</span><span class="p">(</span>
                        <span class="n">ref_name</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">ref_symbol</span><span class="p">,</span> <span class="n">alt</span><span class="p">,</span> <span class="n">filt</span><span class="o">=</span><span class="s1">&#39;PASS&#39;</span><span class="p">,</span>
                        <span class="n">info</span><span class="o">=</span><span class="n">info</span><span class="p">,</span> <span class="n">qual</span><span class="o">=</span><span class="n">q</span><span class="p">,</span> <span class="n">genotype_data</span><span class="o">=</span><span class="n">genotype</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">results</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">snp_metainfo</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return meta data for use in `.vcf` header.&quot;&quot;&quot;</span>
        <span class="n">MI</span> <span class="o">=</span> <span class="n">medaka</span><span class="o">.</span><span class="n">vcf</span><span class="o">.</span><span class="n">MetaInfo</span>
        <span class="n">m</span> <span class="o">=</span> <span class="p">[</span><span class="n">MI</span><span class="p">(</span><span class="s1">&#39;INFO&#39;</span><span class="p">,</span> <span class="s1">&#39;ref_prob&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;Float&#39;</span><span class="p">,</span>
                <span class="s1">&#39;Medaka probability of reference&#39;</span><span class="p">),</span>
             <span class="n">MI</span><span class="p">(</span><span class="s1">&#39;INFO&#39;</span><span class="p">,</span> <span class="s1">&#39;prob&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;Float&#39;</span><span class="p">,</span> <span class="s1">&#39;Medaka probability of variant&#39;</span><span class="p">),</span>
             <span class="n">MI</span><span class="p">(</span><span class="s1">&#39;INFO&#39;</span><span class="p">,</span> <span class="s1">&#39;call&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;String&#39;</span><span class="p">,</span> <span class="s1">&#39;Medaka variant call&#39;</span><span class="p">),</span>
             <span class="n">MI</span><span class="p">(</span><span class="s1">&#39;FORMAT&#39;</span><span class="p">,</span> <span class="s1">&#39;GT&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;String&#39;</span><span class="p">,</span> <span class="s1">&#39;Medaka genotype&#39;</span><span class="p">),</span>
             <span class="n">MI</span><span class="p">(</span><span class="s1">&#39;FORMAT&#39;</span><span class="p">,</span> <span class="s1">&#39;GQ&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;Float&#39;</span><span class="p">,</span> <span class="s1">&#39;Medaka genotype quality score&#39;</span><span class="p">)]</span>

        <span class="k">return</span> <span class="n">m</span></div>


<div class="viewcode-block" id="DiploidZygosityLabelScheme"><a class="viewcode-back" href="../../medaka.html#medaka.labels.DiploidZygosityLabelScheme">[docs]</a><span class="k">class</span> <span class="nc">DiploidZygosityLabelScheme</span><span class="p">(</span><span class="n">DiploidLabelScheme</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Diploid label scheme with an explicit heterozygosity element.</span>

<span class="sd">    The intermediate integer encoding is identical to the</span>
<span class="sd">    DiploidLabelScheme.</span>

<span class="sd">    The training vector encoding is multi-hot. For example, to encode</span>
<span class="sd">    (&#39;A&#39;, C&#39;) at a locus, three elements of the training vectors representing</span>
<span class="sd">    &#39;A&#39;, &#39;C&#39; and &#39;is_heterogygous&#39; are set to 1.</span>

<span class="sd">    (&#39;A&#39;, &#39;C&#39;) -&gt; 6 -&gt; [0, 1, 1, 0, 0, 1]</span>

<span class="sd">    During inference, we predict the probability of each base existing</span>
<span class="sd">    independently, and also (independently) the probability of the locus</span>
<span class="sd">    being heterozygous. A binary crossentropy loss is appropriate.</span>
<span class="sd">    The output vector will not sum to 1.</span>

<span class="sd">    Importantly, during inference, there may be an is_heterozygous</span>
<span class="sd">    prediction &gt; 0.5 which conflicts with independent predictions of which</span>
<span class="sd">    (how many) symbols are present (which symbols have independent</span>
<span class="sd">    probabilities &gt; 0.5. In this case, the is_heterozygous call dominates</span>
<span class="sd">    and we return the top two most probable bases.</span>

<span class="sd">    SNP decoding:</span>

<span class="sd">    [0, 0.6, 0.7, 0, 0, 0.8] -&gt; (&#39;C&#39;, &#39;A&#39;) (in order of most probable)</span>

<span class="sd">    Depending on the reference, this may result in a homozygous or</span>
<span class="sd">    heterozygous SNP call.</span>

<span class="sd">    Where reference is (&#39;A&#39;,), we output ref=&#39;A&#39;, alt=[&#39;C&#39;], GT=&#39;0/1&#39;</span>
<span class="sd">    Where reference is (&#39;T&#39;,), we output ref=&#39;T&#39; alt=[&#39;A&#39;, &#39;C&#39;], GT=&#39;1/2&#39;</span>

<span class="sd">    When predicion is homozygous e.g. (&#39;A&#39;, &#39;A&#39;):</span>
<span class="sd">    Where reference is (&#39;T&#39;,), we output ref=&#39;T&#39;, alt=[&#39;A&#39;], GT=&#39;1/1&#39;</span>

<span class="sd">    When the prediction contains a gap symbol e.g. (&#39;A&#39;, &#39;*&#39;):</span>
<span class="sd">    Where reference is (&#39;T&#39;,), we output ref=&#39;T&#39;, alt=[&#39;A&#39;], GT=&#39;1/1&#39;</span>

<span class="sd">    If the is_heterozygous had been &lt; 0.5, this would alter the call.</span>
<span class="sd">    [0, 0,6, 0.7, 0, 0, 0.4] -&gt; (&#39;C&#39;, &#39;C&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_elements</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return number of elements provided by truth alignment.</span>

<span class="sd">        Synonymous with ploidy.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mi">2</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_classes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return number of elements in output layer of neural network.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">symbols</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">padding_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the integer encoding used to denote a gap.&quot;&quot;&quot;</span>
        <span class="n">gap</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="s1">&#39;*&#39;</span><span class="p">)]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_labels_to_encoded_labels</span><span class="p">(</span><span class="n">gap</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_is_het</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">1</span> <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_singleton</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="k">else</span> <span class="mi">0</span>

<div class="viewcode-block" id="DiploidZygosityLabelScheme.encoded_labels_to_training_vectors"><a class="viewcode-back" href="../../medaka.html#medaka.labels.DiploidZygosityLabelScheme.encoded_labels_to_training_vectors">[docs]</a>    <span class="k">def</span> <span class="nf">encoded_labels_to_training_vectors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">enc_labels</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert integer (tuple) encoded labels to truth vectors.</span>

<span class="sd">        (e.g. one-hot encoded truth vectors) that represent the truth</span>
<span class="sd">        for comparison with network output logits in</span>
<span class="sd">        e.g. metric(truth, pred) or loss(truth, pred)) functions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># we hardcode the conversion between intermediate integer</span>
        <span class="c1"># encodings and the desired multi-hot vectors</span>
        <span class="n">to_training_vector</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span>  <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span>  <span class="c1"># (&#39;*&#39;, &#39;*&#39;)</span>
                              <span class="mi">1</span><span class="p">:</span>  <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span>  <span class="c1"># (&#39;*&#39;, &#39;A&#39;)</span>
                              <span class="mi">2</span><span class="p">:</span>  <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span>  <span class="c1"># (&#39;*&#39;, &#39;C&#39;)</span>
                              <span class="mi">3</span><span class="p">:</span>  <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span>  <span class="c1"># (&#39;*&#39;, &#39;G&#39;)</span>
                              <span class="mi">4</span><span class="p">:</span>  <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span>  <span class="c1"># (&#39;*&#39;, &#39;T&#39;)</span>
                              <span class="mi">5</span><span class="p">:</span>  <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span>  <span class="c1"># (&#39;A&#39;, &#39;A&#39;)</span>
                              <span class="mi">6</span><span class="p">:</span>  <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span>  <span class="c1"># (&#39;A&#39;, &#39;C&#39;)</span>
                              <span class="mi">7</span><span class="p">:</span>  <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span>  <span class="c1"># (&#39;A&#39;, &#39;G&#39;)</span>
                              <span class="mi">8</span><span class="p">:</span>  <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span>  <span class="c1"># (&#39;A&#39;, &#39;T&#39;)</span>
                              <span class="mi">9</span><span class="p">:</span>  <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span>  <span class="c1"># (&#39;C&#39;, &#39;C&#39;)</span>
                              <span class="mi">10</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span>  <span class="c1"># (&#39;C&#39;, &#39;G&#39;)</span>
                              <span class="mi">11</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span>  <span class="c1"># (&#39;C&#39;, &#39;T&#39;)</span>
                              <span class="mi">12</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span>  <span class="c1"># (&#39;G&#39;, &#39;G&#39;)</span>
                              <span class="mi">13</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span>  <span class="c1"># (&#39;G&#39;, &#39;T&#39;)</span>
                              <span class="mi">14</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])}</span>  <span class="c1"># (&#39;T&#39;, &#39;T&#39;)</span>

        <span class="n">vectors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">to_training_vector</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">enc_labels</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">vectors</span></div>

    <span class="k">def</span> <span class="nf">_prob_to_snp</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">outputs</span><span class="p">,</span> <span class="n">positions</span><span class="p">,</span> <span class="n">ref_name</span><span class="p">,</span> <span class="n">ref_symbols</span><span class="p">,</span>
            <span class="n">return_all</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert network output to `medaka.common.Variant` s.&quot;&quot;&quot;</span>
        <span class="c1"># where probability of heterozygosity &gt; 0.5,</span>
        <span class="c1"># we make a heterozygous call, taking the two most</span>
        <span class="c1"># probable symbols.</span>
        <span class="c1"># TODO: optimise this!</span>

        <span class="n">results</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">network_output</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">ref_symbol</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                <span class="n">outputs</span><span class="p">,</span> <span class="n">positions</span><span class="p">,</span> <span class="n">ref_symbols</span><span class="p">):</span>
            <span class="n">het_prob</span> <span class="o">=</span> <span class="n">network_output</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">symbol_probs</span> <span class="o">=</span> <span class="n">network_output</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="n">is_het</span> <span class="o">=</span> <span class="n">het_prob</span> <span class="o">&gt;</span> <span class="mf">0.5</span>

            <span class="n">secondary_call</span><span class="p">,</span> <span class="n">primary_call</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_unitary_decoding</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">symbol_probs</span><span class="p">)[</span><span class="o">-</span><span class="mi">2</span><span class="p">:])</span>
            <span class="n">secondary_prob</span><span class="p">,</span> <span class="n">primary_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">symbol_probs</span><span class="p">)[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span>

            <span class="n">ref_prob</span> <span class="o">=</span> <span class="n">symbol_probs</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_unitary_encoding</span><span class="p">[(</span><span class="n">ref_symbol</span><span class="p">,)]]</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_het</span><span class="p">:</span>
                <span class="n">call</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">((</span><span class="n">primary_call</span><span class="p">,</span> <span class="n">primary_call</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">call</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">((</span><span class="n">primary_call</span><span class="p">,</span> <span class="n">secondary_call</span><span class="p">))</span>

            <span class="n">info</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;ref_prob&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pfmt</span><span class="p">(</span><span class="n">ref_prob</span><span class="p">),</span>
                <span class="s1">&#39;primary_prob&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pfmt</span><span class="p">(</span><span class="n">primary_prob</span><span class="p">),</span>
                <span class="s1">&#39;primary_call&#39;</span><span class="p">:</span> <span class="n">primary_call</span><span class="p">,</span>
                <span class="s1">&#39;secondary_prob&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pfmt</span><span class="p">(</span><span class="n">secondary_prob</span><span class="p">),</span>
                <span class="s1">&#39;secondary_call&#39;</span><span class="p">:</span> <span class="n">secondary_call</span><span class="p">}</span>

            <span class="c1"># logical tests</span>
            <span class="n">is_reference</span> <span class="o">=</span> <span class="n">call</span> <span class="o">==</span> <span class="p">(</span><span class="n">ref_symbol</span><span class="p">,</span> <span class="n">ref_symbol</span><span class="p">)</span>
            <span class="n">contains_deletion</span> <span class="o">=</span> <span class="s1">&#39;*&#39;</span> <span class="ow">in</span> <span class="n">call</span>
            <span class="n">contains_nonref</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span>
                <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">call</span> <span class="k">if</span> <span class="n">s</span> <span class="o">!=</span> <span class="n">ref_symbol</span> <span class="ow">and</span> <span class="n">s</span> <span class="o">!=</span> <span class="s1">&#39;*&#39;</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span>

            <span class="c1"># homozygous</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">((</span><span class="ow">not</span> <span class="n">is_reference</span><span class="p">,</span>
                    <span class="ow">not</span> <span class="n">is_het</span><span class="p">,</span>
                    <span class="ow">not</span> <span class="n">contains_deletion</span><span class="p">)):</span>

                <span class="n">qual</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pfmt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_phred</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">primary_prob</span><span class="p">))</span>
                <span class="n">alt</span> <span class="o">=</span> <span class="n">call</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">genotype</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;GT&#39;</span><span class="p">:</span> <span class="s1">&#39;1/1&#39;</span><span class="p">,</span> <span class="s1">&#39;GQ&#39;</span><span class="p">:</span> <span class="n">qual</span><span class="p">}</span>
                <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">medaka</span><span class="o">.</span><span class="n">vcf</span><span class="o">.</span><span class="n">Variant</span><span class="p">(</span>
                    <span class="n">ref_name</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">ref_symbol</span><span class="p">,</span> <span class="n">alt</span><span class="p">,</span> <span class="n">filt</span><span class="o">=</span><span class="s1">&#39;PASS&#39;</span><span class="p">,</span>
                    <span class="n">info</span><span class="o">=</span><span class="n">info</span><span class="p">,</span> <span class="n">qual</span><span class="o">=</span><span class="n">qual</span><span class="p">,</span> <span class="n">genotype_data</span><span class="o">=</span><span class="n">genotype</span><span class="p">))</span>

            <span class="c1"># heterozygous, no deletions</span>
            <span class="k">elif</span> <span class="nb">all</span><span class="p">((</span><span class="n">is_het</span><span class="p">,</span>
                      <span class="ow">not</span> <span class="n">contains_deletion</span><span class="p">)):</span>

                <span class="n">err</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">primary_prob</span> <span class="o">+</span> <span class="n">secondary_prob</span><span class="p">)</span>
                <span class="n">qual</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pfmt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_phred</span><span class="p">(</span><span class="n">err</span><span class="p">))</span>
                <span class="n">alt</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">call</span> <span class="k">if</span> <span class="n">s</span> <span class="o">!=</span> <span class="n">ref_symbol</span><span class="p">]</span>
                <span class="n">gt</span> <span class="o">=</span> <span class="s1">&#39;0/1&#39;</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">alt</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="s1">&#39;1/2&#39;</span>
                <span class="n">genotype</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;GT&#39;</span><span class="p">:</span> <span class="n">gt</span><span class="p">,</span> <span class="s1">&#39;GQ&#39;</span><span class="p">:</span> <span class="n">qual</span><span class="p">}</span>

                <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">medaka</span><span class="o">.</span><span class="n">vcf</span><span class="o">.</span><span class="n">Variant</span><span class="p">(</span>
                    <span class="n">ref_name</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">ref_symbol</span><span class="p">,</span> <span class="n">alt</span><span class="p">,</span> <span class="n">filt</span><span class="o">=</span><span class="s1">&#39;PASS&#39;</span><span class="p">,</span>
                    <span class="n">info</span><span class="o">=</span><span class="n">info</span><span class="p">,</span> <span class="n">qual</span><span class="o">=</span><span class="n">qual</span><span class="p">,</span> <span class="n">genotype_data</span><span class="o">=</span><span class="n">genotype</span><span class="p">))</span>

            <span class="c1"># heterozygous, one deletion</span>
            <span class="k">elif</span> <span class="nb">all</span><span class="p">((</span><span class="n">is_het</span><span class="p">,</span>
                      <span class="n">contains_nonref</span><span class="p">,</span>
                      <span class="n">contains_deletion</span><span class="p">)):</span>

                <span class="n">qual</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pfmt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_phred</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">primary_prob</span><span class="p">))</span>
                <span class="n">alt</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">call</span> <span class="k">if</span> <span class="n">s</span> <span class="o">!=</span> <span class="s1">&#39;*&#39;</span><span class="p">]</span>
                <span class="n">gt</span> <span class="o">=</span> <span class="s1">&#39;1/1&#39;</span>
                <span class="n">genotype</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;GT&#39;</span><span class="p">:</span> <span class="n">gt</span><span class="p">,</span> <span class="s1">&#39;GQ&#39;</span><span class="p">:</span> <span class="n">qual</span><span class="p">}</span>

                <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">medaka</span><span class="o">.</span><span class="n">vcf</span><span class="o">.</span><span class="n">Variant</span><span class="p">(</span>
                    <span class="n">ref_name</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">ref_symbol</span><span class="p">,</span> <span class="n">alt</span><span class="p">,</span> <span class="n">filt</span><span class="o">=</span><span class="s1">&#39;PASS&#39;</span><span class="p">,</span>
                    <span class="n">info</span><span class="o">=</span><span class="n">info</span><span class="p">,</span> <span class="n">qual</span><span class="o">=</span><span class="n">qual</span><span class="p">,</span> <span class="n">genotype_data</span><span class="o">=</span><span class="n">genotype</span><span class="p">))</span>

            <span class="c1"># no snp at this location</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">return_all</span><span class="p">:</span>
                    <span class="n">qual</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pfmt</span><span class="p">(</span><span class="n">ref_prob</span><span class="p">)</span>
                    <span class="c1"># return variant even though it is not a snp</span>
                    <span class="n">genotype</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;GT&#39;</span><span class="p">:</span> <span class="s1">&#39;0/0&#39;</span><span class="p">,</span> <span class="s1">&#39;GQ&#39;</span><span class="p">:</span> <span class="n">qual</span><span class="p">}</span>
                    <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">medaka</span><span class="o">.</span><span class="n">vcf</span><span class="o">.</span><span class="n">Variant</span><span class="p">(</span>
                        <span class="n">ref_name</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">ref_symbol</span><span class="p">,</span> <span class="n">alt</span><span class="o">=</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="n">filt</span><span class="o">=</span><span class="s1">&#39;PASS&#39;</span><span class="p">,</span>
                        <span class="n">info</span><span class="o">=</span><span class="n">info</span><span class="p">,</span> <span class="n">qual</span><span class="o">=</span><span class="n">qual</span><span class="p">,</span> <span class="n">genotype_data</span><span class="o">=</span><span class="n">genotype</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">results</span></div>


<div class="viewcode-block" id="RLELabelScheme"><a class="viewcode-back" href="../../medaka.html#medaka.labels.RLELabelScheme">[docs]</a><span class="k">class</span> <span class="nc">RLELabelScheme</span><span class="p">(</span><span class="n">HaploidLabelScheme</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Class for RLE labelling schemes.</span>

<span class="sd">    The true length of the runs is encoded in the query scores.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_run</span><span class="o">=</span><span class="mi">12</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialise class.</span>

<span class="sd">        :param max_run: Maximum run length (inclusive) to be</span>
<span class="sd">            considered. This will determine, amongst other things, the size</span>
<span class="sd">            of the labels created.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_run</span> <span class="o">=</span> <span class="n">max_run</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">padding_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the integer encoding used to denote a gap.&quot;&quot;&quot;</span>
        <span class="n">gap</span> <span class="o">=</span> <span class="p">[((</span><span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">)]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_labels_to_encoded_labels</span><span class="p">(</span><span class="n">gap</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="nd">@functools</span><span class="o">.</span><span class="n">lru_cache</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_encoding</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a dictionary mapping from label tuple to integer.&quot;&quot;&quot;</span>
        <span class="n">encoding</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">encoding</span><span class="p">[((</span><span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">bases</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">symbols</span> <span class="k">if</span> <span class="n">s</span> <span class="o">!=</span> <span class="s1">&#39;*&#39;</span><span class="p">]</span>
        <span class="n">lengths</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_run</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">bases</span><span class="p">,</span> <span class="n">lengths</span><span class="p">),</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">encoding</span><span class="p">[((</span><span class="n">b</span><span class="p">,</span> <span class="n">l</span><span class="p">),</span> <span class="p">)]</span> <span class="o">=</span> <span class="n">i</span>

        <span class="k">return</span> <span class="n">encoding</span>

    <span class="k">def</span> <span class="nf">_alignment_to_pairs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">aln</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert `pysam.AlignedSegment` to aligned pairs.&quot;&quot;&quot;</span>
        <span class="n">seq</span> <span class="o">=</span> <span class="n">aln</span><span class="o">.</span><span class="n">query_sequence</span>
        <span class="c1"># pysam gives back 0-based, but we skip the 0 for sanity</span>
        <span class="n">run_lengths</span> <span class="o">=</span> <span class="n">aln</span><span class="o">.</span><span class="n">query_qualities</span>
        <span class="k">for</span> <span class="n">qpos</span><span class="p">,</span> <span class="n">rpos</span> <span class="ow">in</span> <span class="n">aln</span><span class="o">.</span><span class="n">get_aligned_pairs</span><span class="p">():</span>
            <span class="n">qbase</span> <span class="o">=</span> <span class="n">seq</span><span class="p">[</span><span class="n">qpos</span><span class="p">]</span> <span class="k">if</span> <span class="n">qpos</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="s1">&#39;*&#39;</span>
            <span class="c1"># A deletion will have length 1</span>
            <span class="n">qlen</span> <span class="o">=</span> <span class="n">run_lengths</span><span class="p">[</span><span class="n">qpos</span><span class="p">]</span> <span class="k">if</span> <span class="n">qpos</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="mi">1</span>
            <span class="c1"># A larger run length that our maximum run length will be clipped</span>
            <span class="n">qlen</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">qlen</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_run</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">rpos</span><span class="p">,</span> <span class="p">(</span><span class="n">qbase</span><span class="p">,</span> <span class="n">qlen</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_labels_to_encoded_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert a list of tuple labels to array of int encoded labels.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">fromiter</span><span class="p">(</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_encoding</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

<div class="viewcode-block" id="RLELabelScheme.decode_consensus"><a class="viewcode-back" href="../../medaka.html#medaka.labels.RLELabelScheme.decode_consensus">[docs]</a>    <span class="k">def</span> <span class="nf">decode_consensus</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert network output to consensus sequence by argmax decoding.</span>

<span class="sd">        :param sample: medaka.common.Sample</span>

<span class="sd">        :returns: str, consensus sequence</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># property access is slow</span>
        <span class="n">decode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decoding</span>
        <span class="c1"># most probable class</span>
        <span class="n">mp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">sample</span><span class="o">.</span><span class="n">label_probs</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">_get_substrings</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">mp</span><span class="p">:</span>
                <span class="p">((</span><span class="n">base</span><span class="p">,</span> <span class="n">run</span><span class="p">),</span> <span class="p">)</span> <span class="o">=</span> <span class="n">decode</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">base</span> <span class="o">!=</span> <span class="s1">&#39;*&#39;</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">base</span> <span class="o">*</span> <span class="n">run</span>
        <span class="n">seq</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">_get_substrings</span><span class="p">())</span>

        <span class="k">return</span> <span class="n">seq</span></div>

    <span class="k">def</span> <span class="nf">_prob_to_snp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert network output to medaka.common.Variant.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017-19, Oxford Nanopore Technologies

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>